{
  "key": "aave-developer-1",
  "title": "AAVE Developer 1",
  "summary": "This is a technical course for developers willing to write applications on AAVE.\n",
  "details": "In this course we cover the following\n1) Chapter 1 - Information about various smart contracts of AAVE\n2) Chapter 2 - How to pull data from Aave which can be used to create analytics applications\n3) Chapter 3 - How to setup a developer environment to interact with Aave's smart contracts\n4) Chapter 4 - Interacting with Aave's Smart Contracts",
  "duration": "1 - 2 hours",
  "highlights": [
    "AAVE Smart Contract Introduction",
    "Fetching AAVE Data",
    "Developer Environment Setup",
    "Writing simple UI application on top of AAVE"
  ],
  "publishStatus": "Live",
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/DeFi/defi_logo.jpeg",
  "topics": [
    {
      "title": "AAVE Smart Contracts",
      "key": "aave-smart-contracts",
      "details": "This chapter talks about various important smart contracts of AAVE which forms the basis of lending and borrowing\n",
      "order": 0,
      "explanations": [
        {
          "key": "aave-smart-contracts-intro",
          "shortTitle": "Introduction",
          "details": "Aave is a decentralized finance protocol that facilitates lending and borrowing of cryptocurrency tokens usAave ing diverse algorithms and smart contracts without the presence of centralized intermediaries. \nIt is a non-custodial liquidity protocol that allows users to participate as depositors or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an overcollateralized manner.\n\nAave's transition from a decentralized P2P lending approach (a direct loan relationship between lenders and borrowers, similar to ETHLend) to a pool-based strategy is marked by the creation of the Aave Protocol. By putting cryptocurrency in a pool contract, lenders offer liquidity. The pooled funds can also be borrowed inside the same contract by pledging collateral. Loans rely on the pooled money as well as the quantities borrowed and their collateral rather than on individual matching. This makes it possible to quickly lend money with terms that depend on the condition of the pool. Figure 1 below shows a simplified version of the protocol's structure.\n\n![AAVE](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/aave.jpg?raw=true)\n`Reference: https://docs.aave.com/developers/v/2.0/`\n\nThe participants lending the tokens get interest on their loan and the participants borrowing the tokens pay interest. An individual can lend and borrow simultaneously via Aave.\nThe working mechanism of Aave involves allocating a platform specific token, called aTokens to a user's crypto investment. \nThis is what lenders get when they deposit their assets into the pool.\nFor instance, a user who deposits Ethereum in Aave will hold aETH on Aave. \naToken is based on a particular crypto asset and the interest rate each aToken earns is specific to the token deposited, depending on the supply and demand for the original coin.\n\nAave Protocol was created with security in mind and has been audited by various auditors.\nThe White Paper provides a more in-depth look at the protocol, economics, and how it operates.\nOn Github, the Aave Protocol repository can be found here: https://github.com/aave/.\n\n#### Lending and borrowing\nAave has a smart contract based working mechanism wherein the interest rates are determined by different algorithms.\nThe depositors lend the funds in the liquidity pools and earn interest, similarly borrowers can borrow the funds from the liquidity pools. \n\nThe interest rate for both borrowers and lenders is decided algorithmically:\n\n* **Interest rate for Borrowers**: The interest rate to be paid by the borrowers depends on the cost of money and the amount of funds available in the pool at a specific time.The amount of funds present in the pool has an inverse relationship with the interest rate. As funds are borrowed from the pool, the amount of funds available decreases which raises the interest rate. \n\n* **Interest rate for Lenders**: The interest rate received by the lenders corresponds to the earn rate, with the algorithm safeguarding a liquidity reserve to guarantee withdrawals at any time.\n\nAnd since cryptocurrency is highly volatile, borrowing in Aave demands overcollateralization. \nFor example-  Kevin wants to borrow $500 worth of ETH from the AAve protocol. In order to do so, Kevin will have to put up more than that amount in a different cryptocurrency. If the price falls and the amount in collateral no longer covers the amount borrowed, the collateral can be liquidated, meaning the protocol takes it to cover the cost of the loan.\nA liquidation event happens when the price of the collateral drops below the liquidation threshold.\n",
          "title": "Introduction"
        },
        {
          "title": "Important Tech Terms",
          "shortTitle": "Tech Terms",
          "key": "terminology",
          "details": "* **APY**: Annual Percentage Yield is the yield/interest after a year, including compounding interest. This differs from the Annual Percentage Rate (APR), which does not account for compounding effects.\n\n* **Liquidity Index**: The reserve's interest accumulation during the time span since the last updated timestamp.\n\n* **Loan To Value**: The maximum borrowing capacity of a particular collateral. If a collateral has a Loan to Value of 75%, the user will be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of collateral. The Loan To Value is represented in percentage points and is set per collateral.\n\n* **Liquidation Threshold**: The amount of a borrow position that must be liquidated because it is undercollateralized. When a collateral has an 80% liquidation threshold, it signifies that the loan will be liquidated when the debt value equals 80% of the collateral value. The liquidation threshold is defined in percentage points and is specified per collateral.\n\n* **Liquidation Bonus**: The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one. The Liquidation Bonus is defined in percentage points and is determined per collateral.\n\n* **Health factor**: The ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.\n\n* **Stable rate**: A loan with a stable rate behaves like a fixed rate loan in the short term, but the rates can be rebalanced in the medium/long term in response to rapid market movements.\n\n* **Reserve** : Reserves are the underlying assets' ERC-20 contracts.\n\n* **Variables in Code**\nFollowing is the list of most common variables used in the code:\n\n| Parameter Name             | Type            | Description                                                                                                                                            |\n| -------------------------- | --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| reserve                    | address         | address of the [underlying asset](https://docs.aave.com/developers/v/1.0/deployed-contracts/deployed-contract-instances#reserves-assets)               |\n| amount                     | uint256         | amount to borrow/deposit/repay, expressed in decimal units                                                                                             |\n| referralCode               | uint256         | referral code for the referral program                                                                                                                 |\n| useAsCollateral            | bool            | if true, the asset is allowed as a collateral for borrow                                                                                               |\n| interestRateMode           | uint256         | type of interest rate mode to use, with uint 2 representing variable rate and uint 1 representing stable rate                                          |\n| onBehalfOf                 | address payable | address to repay on behalf of. If the caller is repaying their own loan, then this value should be equal to msg.sender                                 |\n| user                       | address         | address of the user to rebalance                                                                                                                       |\n| collateral                 | address         | address of the liquidated collateral reserve                                                                                                           |\n| purchaseAmount             | uint256         | amount of the discounted purchase                                                                                                                      |\n| receiveaToken              | bool            | if true, the user receives the aTokens equivalent of the purchased collateral. If false, the user receives the underlying asset directly               |\n| timestamp                  | uint256         | timestamp of the transaction, in Unix time                                                                                                             |\n| borrowRateMode             | uint256         | interest rate mode 0 for None, 1 for stable and 2 for variable                                                                                         |\n| borrowRate                 | uint256         | APY of the loan at the time of the borrow() call. in Wei.                                                                                              |\n| originationFee             | uint256         | amount of the originationFee of the loan, in [Ray units](https://docs.aave.com/developers/v/1.0/developing-on-aave/important-considerations#ray-math). |\n| borrowBalanceIncrease      | uint256         | amount of debt increased since the last update by the user, in Wei.                                                                                    |\n| repayer                    | uint256         | address of the repayer                                                                                                                                 |\n| amountMinusFees            | uint256         | amount repayed, without fees.                                                                                                                          |\n| fees                       | uint256         | fees paid                                                                                                                                              |\n| purchaseAmount             | uint256         | amount of the liquidation, in Wei.                                                                                                                     |\n| liquidatedCollateralAmount | uint256         | amount of collateral being liquidated                                                                                                                  |\n| accruedBorrowInterest      | uint256         | amount of debt increased since the last update by the user, in Wei.                                                                                    |\n| liquidator                 | address         | address of the liquidator                                                                                                                              |\n| receiveAToken              | bool            | true if the liquidator wants to receive aTokens, false otherwise.                                                                                      |\n"
        },
        {
          "key": "architecture",
          "title": "AAVE Architecture",
          "shortTitle": "Architecture",
          "details": "Aave has released three versions (v1, v2 and v3) as of now and the Governance token of Aave is \"AAVE\". Version 1 or v1 is the base version launched in 2017 and then there have been upgrades with multiple new features added. \nAave v2 improves on many areas of v1, allowing developers to create a wide new design space in which to construct products and services. If you previously developed on Aave v1, you should be aware of the following changes:\n* There is no longer a LendingPoolCore contract in Aave v2 that retains all of the protocol's assets. Assets are held directly in the linked aToken contracts, with the LendingPool contract serving as the protocol's \"core.\"\n* Almost all actions in Aave v2 should be executed via the LendingPool contract. This differs from v1, when a redemption/withdrawal of aTokens required a call on the aToken contract.\n* After depositing collateral into the protocol, a user can easily delegate credit to any address by using approveDelegation() on the relevant debt token.\n* Flash loans are possible inside the Aave v2 protocol. Indeed, they are widely utilised within the protocol for position switching and other 'trading'-like functions.\n* Flash loans can now be executed in batches, which means that many flash loans with varied parameters can be performed in the same call. This opens the door to strong new use cases, such as repaying numerous assets and positions with a single flash loan transaction.\n* You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt (i.e. the flash loan is not paid back immediately).\n* AddressesProviders will be numerous in multiple markets. The AddressesProviderRegistry will keep track of all Aave market address providers.\n* LendingPoolCore has been decommissioned. Only LendingPool is used, which simplifies integrations and Aave v2 development.\nThe v3 improved features enable new use cases, sparking a flood of innovation from users and developers. Aave V3 generates I mprovements in all of the these areas - capital efficiency, security, decentralisation, and UX - while simultaneously delivering new functions to harness the capabilities of rollups and the developing ecosystem of rival L1s.\n* Portal is a new set of core functionalities that can be utilised to enable provided assets to move easily between Aave markets on different networks. On the surface, the feature is fairly simple: the protocol uses the aTokens' unique pegged design to burn aTokens on the source network while minting them on the destination network.\n* Borrowers can use High Efficiency Mode (E-Mode) to get the most borrowing power out of their collateral. Borrowers can use E-Mode to limit their borrowing to only assets in a specific category (e.g., stablecoins).\n* One of the most important areas for improvement is managing the inherent complexities of risk exposure modulation.\n* Repay with aTokens: Allows borrowers to repay with aTokens rather than the underlying asset.\n* Despite all of the new features, the overall gas cost of all functions fell by about 25%.\n* Smart contract re-engineering has considerably reduced code size (leaving more room for future revisions) by up to 100K optimizer runs!\n* All token transfer functions (supply, repay) now support EIP 2612 authorization (this is especially important for L2).\n* Signature on EIP 712 for credit delegation (no need for contracts to request a user transaction anymore).\n\n#### Protocol Overview\n\nOn Github, the Aave Protocol repository can be found here: https://github.com/aave/\nBelow image provides an overview of the protocol.\n\n![Architecture](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/architechture.png?raw=true)\n`Reference: https://docs.aave.com/developers/v/2.0/the-core-protocol/protocol-overview`\n\n#### Main Contracts\nThe main contracts in Aave and their purposes are:\n* LendingPool: The main entry point into the Aave Protocol. Most interactions with Aave will happen via the LendingPool, including:\n  - `deposit()`\n  - `borrow()`\n  - `repay()`\n  - `swapBorrowRateMode()`\n  - `setUserUseReserveAsCollateral()`\n  - `withdraw()`\n  - `flashloan()`\n  - `liquidationCall()`\n* LendingPoolAddressesProvider: The protocol's primary addresses register for specific marketplaces. The most recent contract addresses should be obtained from this contract by making the necessary calls.\n* LendingPoolAddressesProviderRegistry: Contains a list of active LendingPoolAddressesProvider addresses, for different markets.\n* aTokens: The yield-producing, tokenized deposits that are used throughout the Aave protocol. They implement, with minor modifications, the majority of the standard EIP-20/ERC20 token methods, as well as Aave-specific methods such as:\n  - `scaledBalanceOf()`\n  - `getScaledUserBalanceAndSupply()`\n  - `scaledTotalSupply()`\n\n  All aTokens also implement EIP-2612, which via the permit() function enables gas-less transfers and single transaction approve + actions.\n* Stable and Variable Debt Tokens: The Aave protocol employs tokenised borrow locations throughout. Because debt tokens are non-transferable, most common EIP-20/ERC20 techniques are disabled.\n\n#### Supporting contracts\nThe following contracts should generally not be interacted with directly, but are used throughout the Aave Protocol via contract calls.\n* LendingPoolCollateralManager: The LendingPoolCollateralManager implements protocol activities involving collateral management using delegatecall via the LendingPool contract, including:\n  - liquidationCall()\nOnly the primary LendingPool contract should be used to call the above function.\n* Lending Pool Configurator: Configuration functions for LendingPool contracts are provided. It also serves a variety of vital purposes:\n  - Activates / Deactivates reserves,\n  - Enables / Disables borrowing for a reserve,\n  - Enables / Disables using a reserve as collateral,\n  - Enables / Disables stable rate borrowing for a reserve,\n  - Freezes / Unfreezes reserves,\n  - Updates a reserve's Loan to Value,\n  - Updates a reserve's liquidation threshold,\n  - Updates a reserve's liquidation bonus,\n  - Updates a reserve's decimals,\n  - Updates a reserve's interest rate strategy address,\n  - Activates / Deactivates all functions of a LendingPool in emergencies.\n\n  For all of the above functions, relevant events are emitted to the blockchain. Anyone can monitor these changes to know when values have been modified or added/removed.\n* Interest Rate Strategy: Contains the data required to calculate and adjust the interest rates on individual reserves.\nEach contract stores the optimised base curves using the relevant currency parameters. This means that each asset pool's interest rate is determined by a mathematical function, with the interest rate varying based on the amount of borrowed funds and the asset pool's total liquidity (i.e. utilisation).\nThe parameters for the optimised base curves are:\n  - baseVariableBorrowRate\n  - variableRateSlope1\n  - variableRateSlope2\n  - stableRateSlope1\n  - stableRateSlope2\n\nThe interest rates are calculated depending on the available liquidity and the total borrowed amount.\n"
        },
        {
          "key": "functions-1",
          "title": "AAVE Functionalities in Details - I",
          "shortTitle": "Functions - I",
          "details": "The LendingPool contract is the protocol's principal contract. It exposes all user-oriented operations that may be performed with the Solidity or web3 libraries. The source code is available [here](https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPool.sol).\nTo concentrate on method interactions, Web3 code samples remove imports and transactional sections. Join the #developers channel on the [Aave community Discord server](https://discord.gg/fVaDMqT) if you require development assistance.\n\n#### Deposit/Lending\nLenders share the interest payments made by borrowers based on the utilization rate multiplied by the average borrowing rate. The yield for depositors increases as reserve utilization increases.\nLenders are also entitled to a portion of the Flash Loan fees, equal to 0.09% of the Flash Loan volume.\nThere is no minimum or maximum deposit amount; you may deposit any amount you choose.\n\n#### Methods\n####  `function deposit( address _reserve, uint256 _amount, uint16 _referralCode)`\n\nDeposits a certain `_amount` of an asset specified by the `_reserve` parameter.\nIn exchange, the caller receives a specific number of aTokens. aTokens can be redeemed for the underlying token in a 1:1 ratio.\n\nPlease see the referral programme section for further information about `_referralCode` input. You can use the referral code: 0 during testing.\n\nWhen depositing an ERC-20 token, the `LendingPoolCore` contract (not the `LendingPool` contract) must have the required allowance of `_amount` for the underlying ERC20 of the `_reserve` asset via `approve()`.\nEmitted events: `_reserve`, `_user`, `_amount`, `_referral`, `_timestamp`\n\n**ETH deposits**\nBecause the protocol does not employ an EIP-20 wrapper like wETH for ETH deposits, the deposit() method's amount parameter must match the transaction's msg.value parameter and be included in your deposit() call.\nE.g: `lendingPool.deposit{ value: msg.value }(reserve, msg.value, referralCode)`\nBecause ETH is utilized directly in the protocol (rather than an abstraction like WETH), we use a dummy address to represent it: `0xEeeeeEeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`\n\n**ERC20 deposits**\nThe _reserve parameter corresponds to the underlying asset's ERC20 contract address. [Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L753)\n\nThe deposit() flow within the protocol:\n<div class=\"flex justify-center max-h-96\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH4HvCIm09jkjFv%2Flending%20pool%20deposit.png?alt=media&token=c92f8256-9d73-41a1-9e96-a3d807425d08\" />\n</div> \n\n#### `function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)`\n\nAllow the user's deposit to be used as collateral. Users will only be able to disable deposits that are not being used as collateral at the time. [Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L341 )\n\n**Stable vs Variable Interest Rate**\n\nIn the short-term, stable rates function as a fixed rate, but they can be rebalanced in the long run in reaction to alterations in the market environment. Depending on supply and demand in Aave, the variable rate can change.\nThe stable rate is the better choice for forecasting how much interest you will have to pay because, as its name suggests, it will remain fairly stable. The variable rate changes over time and, depending on market conditions, could be the optimal rate.\n"
        },
        {
          "key": "functions-2",
          "title": "AAVE Functionalities in Details - II",
          "shortTitle": "Functions - II",
          "details": "#### Borrow\nYou must deposit any asset to be used as collateral before borrowing.The amount you can borrow depends on the value you have deposited and the readily available liquidity.For instance, if there isn’t enough liquidity or if your health factor (minimum threshold of the collateral = 1, below this value, liquidation of your collateral is triggered) prevents it, you can’t borrow an asset. The loan is repaid with the same asset that you borrowed.\nFor instance, if you borrow 1 ETH, you’ll need to pay back 1 ETH plus interest.\nIn the updated Version 2 of the Aave Protocol, you can also use your collateral to make payments. You can borrow any of the stablecoins like USDC, DAI, USDT, etc. if you want to repay the loan based on the price of the USD.\n\n#### Methods\n#### borrow()\n**function borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode)** \nTransfers a certain amount of the asset identified by the _reserve parameter to the msg.sender, provided the caller has deposited enough collateral to fund the borrow in advance.\nEvery loan can be opened in either a fixed or variable rate mode. Borrows have an indefinite term and no payback date. In the event of market swings, a borrow position is liquidated if the collateral price falls below a specific threshold. Please read the White Paper to learn more about the stable rate economy.\nPlease see the [referral programme section](https://docs.aave.com/developers/v/1.0/integrating-aave/referral-program) for further information about _referralCode input. You can use the referral code: 0 during testing.\nEmitted events: _reserve, _user, _amount, _referral, _timestamp, _borrowRateMode, _borrowRate, _originationFee, _borrowBalanceIncrease\n\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L219 )\n\nThe borrow() flow within the protocol:\n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH3GOEvYvbizwHC%2Flending%20pool%20borrow.png?alt=media&token=2031b536-733e-4a8a-866c-23c86706e641\" class=\"max-h-48\" />\n</div> \n\n#### repay()\n**function repay( address _reserve, uint256 _amount, address payable _onBehalfOf)**\nRepay a borrowed asset in whole or in part. The _onBehalfOf parameter can be used to repay a different user's debt.\nWhen a third-party repays another user's debt on their behalf, the third-party address must approve() the LendingPoolCore contract (which is separate from the LendingPool contract) with the _amount of the underlying ERC20 of the _reserve contract.\nEmitted events: _reserve, _user, _repayer, _fees, _referral, _timestamp, _amountMinusFees, _borrowBalanceIncrease\n\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L249)\n\nThe repay() flow within the protocol: \n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH9NighH7i_73lI%2Flending%20pool%20repay.png?alt=media&token=cb6e102e-222b-412a-92f0-763ae34e7cce\" />\n</div>  \n\n#### swapBorrowRateMode()\n**function swapBorrowRateMode(address _reserve)**\nChanges the borrow rate modes of the msg.sender from stable to variable.\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L326) \n\n#### rebalanceStableBorrowRate()\n**function rebalanceStableBorrowRate(address _reserve, address _user)**\nRebalances the stable rate of _user\n[Code here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L336) \n\nThe rebalance flow for stable rates in the protocol: \n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH7rY4WFE5jRwrB%2Flending%20pool%20rebalancing.png?alt=media&token=8a442d62-6087-4adf-b27b-163478547f79\" />\n</div>   \n\n#### liquidationCall()\n**function liquidationCall(address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveaToken)**\nPositions with a health factor less than one should be liquidated.\nWhen a position's health factor falls below one, liquidators repay part or all of the outstanding borrowed amount on behalf of the borrower in exchange for a discounted quantity of collateral (sometimes known as a liquidation \"bonus\"). Liquidators have the option of receiving an equal quantity of collateral aTokens or the underlying asset directly. When the liquidation is completed successfully, the position's health factor is enhanced, bringing it above 1.\nA close factor determines how much collateral a liquidator can close. The current close factor is 0.5. In other words, liquidators can only liquidate up to 50% of the amount owing in a position. This is the amount of the liquidation discount.\nLiquidators must approve() the LendingPoolCore contract (which is distinct from the LendingPool contract) in order to use the underlying ERC20 of the _reserve asset for the liquidation.\n**NOTE**: In most cases, profitable liquidators will choose to liquidate as much of the _user position as possible.\npurchaseAmount parameter can be set to uint(-1) and the protocol will proceed with the largest liquidation allowed by the close factor.\nFor ETH liquidations, the transaction's msg.value should be identical to the _purchaseAmount parameter.\nTo determine a user's health factor, use getUserAccountData().\n[Code Here](https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L360) \n\nThe liquidation flow in the protocol:\n<div class=\"flex justify-center max-h-48\">\n<img src=\"https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH6dX0q9LDXBn9X%2Flending%20pool%20liquidation.png?alt=media&token=6701e381-1fd1-42ce-919b-39da57434c57\" />\n</div>   \n"
        },
        {
          "title": "AAVE Functionalities in Details - III",
          "shortTitle": "Functions - III",
          "key": "functions-3",
          "details": "Flash Loans are special transactions that allow you to borrow an asset as long as the borrowed amount (plus a fee) is returned before the transaction ends (also called One Block Borrows). These transactions do not necessitate the provision of collateral by the user prior to the transaction. Because there is no real-world equivalent for Flash Loans, some basic grasp of how the state is managed within blocks in blockchains is required.\nDue to the technical understanding necessary to execute one, flash loans are a feature developed for developers. To use this feature, you must have a solid understanding of EVM, programming, and smart contracts. To do a Flash Loan, you must first create a contract requesting a Flash Loan. The contract must follow the instructions and repay the loan plus interest and fees in the same transaction.\n\nCan you use Flash Loans without knowing how to code?\nYes, there are currently programs available that enable end users to gain from Flash Loans, such as [defisaver](https://defisaver.com/) and [collateralswap](https://collateralswap.com/). At https://medium.com/aave/sneak-peek-at-flash-loans-f2b28a394d62 , you may find more application cases.\nEven those without coding experience may use Flash Loans because of user interfaces like the one [furucombo](https://furucombo.app/) offers. Details are provided below: https://medium.com/furucombo/create-flashloan-combo-on-furucombo-c7c3b23267f0 \n\nAave v3 provides two flash loan options:\n**flashLoan**: Allows the borrower to obtain liquidity from various reserves in a single flashLoan transaction. In this instance, the borrower has the option of opening a stable or variable rate debt position backed by supplied collateral or credit delegation.\n**NOTE**: For qualified flashBorrowers, the loan charge is waived (managed by ACLManager)\n**flashLoanSimple**: Allows the borrower to access a single reserve of liquidity for the transaction. In this situation, the flash loan fee is not waived, and the borrower is not permitted to open any debt positions at the conclusion of the transaction. For individuals attempting to take advantage of a simple flash loan with a single reserve asset, this strategy is gas efficient.\n\n#### Flow of Execution\nA helpful mental model to consider when creating your solution for developers:\n* Your contract contacts the Pool contract and requests a Flash Loan for a specific amount(s) of reserve(s) using flashLoanSimple() or flashLoan() ().\n* The Pool sends the requested amounts of reserves to your contract after some sanity checks, then executes executeOperation() on the receiver contract.\n* Your contract now does any arbitrary operation in its code while holding the flash borrowed amount(s).\n* When you finish your code for a flashLoanSimple, you approve Pool for the flash loaned amount + charge.\n* If you are executing flashLoan, then all reserves must be granted for flash borrowed amount + fee or adequate collateral or credit delegation must be provided to start debt position, based on the interestRateMode passed for the asset.\n* If the amount owed is not available (due to a lack of balance or authorisation, or insufficient debt collateral), the transaction is reverted.\n* All of the preceding occurs in a single transaction (hence in a single ethereum block).\n\n#### Flash Loan Applications\nAave Flash Loans are already used for the liquidity swap functionality in Aave V3. Other real-world instances include: arbitrage between assets without requiring the main amount to be present.\nLiquidating borrow positions without having to repay the debt of the positions and paying off flashLoan amount + charge with discounted collateral claimed.\n\n#### Fee for a Flash loan\nThe flash loan charge is set to 0.09% at deployment and can be changed via Governance Vote. To obtain the current value, use FLASHLOAN PREMIUM TOTAL.\nThe LPs (liquidity providers) and the protocol treasury can split the flashloan charge. The FLASHLOAN PREMIUM TOTAL variable represents the total charge paid by borrowers, which includes:\nFee to LP: FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL\nFee to Protocol: FLASHLOAN_PREMIUM_TO_PROTOCOL\nAt initialization, FLASHLOAN_PREMIUM_TO_PROTOCOL is 0.\n\n#### First step: Setting Up\nBy implementing the relevant executeOperation() function, your contract that receives the amounts from flash loans must comply with the IFlashLoanSimpleReceiver.sol or IFlashLoanReceiver.sol interface.\nAdditionally, keep in mind that since the owing sums will be deducted from your contract, your contract must let the Pool to deduct those monies in order to repay the flash loan amount plus premiums.\n\n#### Second Step: Calling flashLoan() or flashLoanSimple()\nTo invoke either of the Pool's two flash lending methods, we must provide the necessary parameters. There are three possibilities:\n* From an EOA ('normal' Ethereum account)\n  - To use an EOA, send a transaction to the appropriate Pool and use the flashLoan() or flashLoanSimple() functions. For parameter information, see the Pool API documentation, making sure to use your contract address from step 1 for the receiverAddress.\n* From a different contract\n  - As with transmitting a transaction from an EOA, make sure the receiverAddress matches your contract address from step 1.\n* From the same contract\n  - Utilize address(this) for the receiverAddress parameter in the flash loan method if you wish to use the same contract as in step 1.\n**Note**: Never keep funds permanently on your FlashLoanReceiverBase contract as they could be exposed to a ['griefing' attack](https://ethereum.stackexchange.com/a/92457/19365), where the stored funds are used by an attacker.\n\n#### Final Step: Completing the flash loan\nIf you used flashLoanSimple() or interestRateMode=0 in flashLoan() for any of the assets in the modes parameter, you will need to repay the flash loaned amounts once you have completed your logic with the flash loaned assets (in your executeOperation() method).\n* Repaying a flash loaned asset\n  - Check that your contract includes the appropriate amount + premium to repay the borrowed asset. This can be calculated by adding the relevant entries in the amounts and premiums array given to the executeOperation() function. \\\n  - You are not required to return the owing sum to the Pool. The cash will be automatically withdrawn at the end of your operation.\n* Getting into debt (i.e. not immediately paying back)\n  - If you used mode=1 or mode=2 for any of the assets in the modes parameter, the address put in for onBehalfOf will incur the obligation if the onBehalfOf address previously authorised the msg.sender to incur debts on their behalf.\n  - This means that you can have some assets that are promptly paid back while others incur debt.\n"
        }
      ],
      "questions": [
        {
          "uuid": "7e267f35-7837-4aa9-9081-9ec8ab708a79",
          "type": "SingleChoice",
          "content": "Select the correct option.",
          "hint": "NoHint",
          "explanation": "Since cryptocurrency is highly volatile, borrowing in Aave demands overcollateralization.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "aave-smart-contracts-intro"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Borrowing in Aave is undercollateralized",
              "key": "A"
            },
            {
              "content": "Borrowing in Aave is overcollateralized",
              "key": "B"
            },
            {
              "content": "Depositing in Aave is overcollateralized",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "98442878-4460-4bdd-88f0-1b2a9bce6dfd",
          "type": "SingleChoice",
          "content": "When does a liquidation event occur?",
          "hint": "NoHint",
          "explanation": "A liquidation event happens when the price of the collateral drops below the liquidation threshold.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "aave-smart-contracts-intro"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "When the price of the collateral rises above the liquidation threshold",
              "key": "A"
            },
            {
              "content": "When the price of the collateral is equal to the liquidation threshold",
              "key": "B"
            },
            {
              "content": "When the price of the collateral drops below the liquidation threshold",
              "key": "C"
            },
            {
              "content": "When the price of the collateral doubles the liquidation threshold",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "db260d6f-9851-459f-9170-b59d73460723",
          "type": "SingleChoice",
          "content": "What is Liquidation Bonus?",
          "hint": "NoHint",
          "explanation": "Liquidation bonus is the bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor more than one",
              "key": "A"
            },
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor equal to one",
              "key": "B"
            },
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor more than or equal to one",
              "key": "C"
            },
            {
              "content": "The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b8d4ad4a-c761-47f2-ad99-2904f842fbd2",
          "type": "SingleChoice",
          "content": "What is the maximum borrowing capacity of a particular collateral known as?",
          "hint": "NoHint",
          "explanation": "Loan To Value is the maximum borrowing capacity of a particular collateral. If a collateral has a Loan to Value of 75%, the user will be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of collateral. The Loan To Value is represented in percentage points and is set per collateral.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Liquidation Threshold",
              "key": "A"
            },
            {
              "content": "Liquidity Index",
              "key": "B"
            },
            {
              "content": "Loan To Value",
              "key": "C"
            },
            {
              "content": "Liquidation Bonus",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "619a9931-752e-4a4e-b88b-7700603d1c51",
          "type": "SingleChoice",
          "content": "What do you understand by liquidation threshold?",
          "hint": "NoHint",
          "explanation": "Liquidation Threshold is the amount of a borrow position that must be liquidated because it is undercollateralized. When a collateral has an 80% liquidation threshold, it signifies that the loan will be liquidated when the debt value equals 80% of the collateral value. The liquidation threshold is defined in percentage points and is specified per collateral.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The amount of a borrow position that must be liquidated because it is undercollateralized",
              "key": "A"
            },
            {
              "content": "The ratio of total collateral multiplied by the liquidation threshold to borrowed principal",
              "key": "B"
            },
            {
              "content": "The amount of a borrow position that must be liquidated because it is overcollateralized",
              "key": "C"
            },
            {
              "content": "The maximum borrowing capacity of a particular collateral",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3326b2c9-6f6e-4f38-b724-2f5a3d758d1f",
          "type": "SingleChoice",
          "content": "How many versions of the AAVE protocol have been released?",
          "hint": "NoHint",
          "explanation": "Aave has released three versions (v1, v2 and v3) as of now.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "One",
              "key": "A"
            },
            {
              "content": "Two",
              "key": "B"
            },
            {
              "content": "Three",
              "key": "C"
            },
            {
              "content": "Zero",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "fb570d02-88db-425f-8d8f-3f4f8a38b9ce",
          "type": "SingleChoice",
          "content": "What is Health Factor?",
          "hint": "NoHint",
          "explanation": "Health factor is the ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The ratio of total collateral multiplied by the liquidation threshold to borrowed principal",
              "key": "A"
            },
            {
              "content": "The ratio of total collateral multiplied by the borrowed principal to liquidation threshold",
              "key": "B"
            },
            {
              "content": "The ratio of total collateral to borrowed principal",
              "key": "C"
            },
            {
              "content": "The ratio of total collateral to liquidation threshold",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2613cb0b-1247-4471-b174-f5ff2f7fbc47",
          "type": "SingleChoice",
          "content": "Which contract has been decommissioned in Aave v2?",
          "hint": "NoHint",
          "explanation": "LendingPoolCore has been decommissioned. Only LendingPool is used, which simplifies integrations and Aave v2 development.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "LendingPoolAddressesProvider",
              "key": "A"
            },
            {
              "content": "LendingPool",
              "key": "B"
            },
            {
              "content": "LendingPoolCore",
              "key": "C"
            },
            {
              "content": "LendingPoolAddressesProviderRegistry",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "5d69612e-6241-4bfc-a247-b7ef12f9e9c0",
          "type": "MultipleChoice",
          "content": "Pick the correct option(s).",
          "hint": "NoHint",
          "explanation": "Flash loans can now be executed in batches, which means that many flash loans with varied parameters can be performed in the same call. This opens the door to strong new use cases, such as repaying numerous assets and positions with a single flash loan transaction. You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt (i.e. the flash loan is not paid back immediately).",
          "answerKeys": [
            "A",
            "C"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Many flash loans with varied parameters can now be performed in the same call",
              "key": "A"
            },
            {
              "content": "Many flash loans with varied parameters can not be performed in the same call",
              "key": "B"
            },
            {
              "content": "You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt",
              "key": "C"
            },
            {
              "content": "You can not do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1e7412d2-0f89-4fd1-b742-5ea072b8efb6",
          "type": "SingleChoice",
          "content": "Which contract is the main entry point into the Aave Protocol?",
          "hint": "NoHint",
          "explanation": "LendingPool is the main entry point into the Aave Protocol. Most interactions with Aave will happen via the LendingPool.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "overview"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "LendingPoolAddressesProvider",
              "key": "A"
            },
            {
              "content": "LendingPool",
              "key": "B"
            },
            {
              "content": "LendingPoolCore",
              "key": "C"
            },
            {
              "content": "LendingPoolAddressesProviderRegistry",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f27e3567-22d4-441a-9b29-5e306dcff815",
          "type": "SingleChoice",
          "content": "Which contract can be used to obtain the most recent contract addresses?",
          "hint": "NoHint",
          "explanation": "LendingPoolAddressesProvideris the protocol's primary addresses register for specific marketplaces. The most recent contract addresses should be obtained from this contract by making the necessary calls.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "overview"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "LendingPoolAddressesProvider",
              "key": "A"
            },
            {
              "content": "LendingPool",
              "key": "B"
            },
            {
              "content": "LendingPoolCore",
              "key": "C"
            },
            {
              "content": "LendingPoolAddressesProviderRegistry",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "09ef1435-b99e-457d-bb95-b8f493d6b14e",
          "type": "SingleChoice",
          "content": "Which of the following methods is not included in the LendingPool contract?",
          "hint": "NoHint",
          "explanation": "Most interactions with Aave will happen via the LendingPool, including deposit(), borrow(), repay(), swapBorrowRateMode(), setUserUseReserveAsCollateral(), withdraw(), flashloan(), liquidationCall().",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "overview"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "deposit()",
              "key": "A"
            },
            {
              "content": "borrow()",
              "key": "B"
            },
            {
              "content": "withdraw()",
              "key": "C"
            },
            {
              "content": "scaledTotalSupply()",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7c7535a8-942c-4d6f-a49c-ecbbb587f175",
          "type": "SingleChoice",
          "content": "Despite all of the new features added in v3, the overall gas cost of all functions fell. By what percentage did the gas cost fall?",
          "hint": "NoHint",
          "explanation": "explanation",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "versions"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The overall gas cost of all functions fell by about 50%",
              "key": "A"
            },
            {
              "content": "The overall gas cost of all functions fell by about 25%",
              "key": "B"
            },
            {
              "content": "The overall gas cost of all functions fell by about 2.5%",
              "key": "C"
            },
            {
              "content": "The overall gas cost of all functions fell by about 5%",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "aadd93bd-8e38-4969-9f4d-ecbc5f2f3802",
          "type": "SingleChoice",
          "content": "Can any individual lend and borrow simultaneously via Aave?",
          "hint": "NoHint",
          "explanation": "An individual can lend and borrow simultaneously via Aave. The participants lending the tokens get interest on their loan and the participants borrowing the tokens pay interest.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "aave-smart-contracts-intro"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Yes, any individual lend and borrow simultaneously via Aave",
              "key": "A"
            },
            {
              "content": "No, any individual can not lend and borrow simultaneously via Aave",
              "key": "B"
            },
            {
              "content": "Only possible when the price of the collateral drops below the liquidation threshold",
              "key": "C"
            },
            {
              "content": "Only possible when the price of the collateral rises above the liquidation threshold",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "13dc4af8-4bac-44d8-8977-26a93135de9c",
          "type": "SingleChoice",
          "content": "What happens when the Health Factor falls below one?",
          "hint": "NoHint",
          "explanation": "Health factor is the ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "terminology"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The loan is considered overcollateralized and can be liquidated.",
              "key": "A"
            },
            {
              "content": "The loan is considered undercollateralized and can not be liquidated.",
              "key": "B"
            },
            {
              "content": "The loan is considered undercollateralized and can be liquidated.",
              "key": "C"
            },
            {
              "content": "The loan is considered overcollateralized and can not be liquidated.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2100e607-e07e-4c5b-a2b6-44301d59363e",
          "type": "SingleChoice",
          "content": "What is the ratio in which aTokens can be redeemed for the underlying token?",
          "hint": "NoHint",
          "explanation": "aTokens can be redeemed for the underlying token in a 1:1 ratio",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "functions-1"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "aTokens can be redeemed for the underlying token in a 1:10 ratio",
              "key": "A"
            },
            {
              "content": "aTokens can be redeemed for the underlying token in a 11:1 ratio",
              "key": "B"
            },
            {
              "content": "aTokens can be redeemed for the underlying token in a 1:1 ratio",
              "key": "C"
            },
            {
              "content": "aTokens can be redeemed for the underlying token in a 1:11 ratio",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d97848fc-cec7-4ce4-b39f-694fc565ca65",
          "type": "MultipleChoice",
          "content": "Pick the correct option(s).",
          "hint": "NoHint",
          "explanation": "Because the protocol does not employ an EIP-20 wrapper like wETH for ETH deposits, the deposit() method's amount parameter must match the transaction's msg.value parameter and be included in your deposit() call.",
          "answerKeys": [
            "A",
            "c"
          ],
          "subTopics": [
            "functions-1"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "AAVE protocol does not employ an EIP-20 wrapper",
              "key": "A"
            },
            {
              "content": "AAVE protocol employs an EIP-20 wrapper",
              "key": "B"
            },
            {
              "content": "The deposit() method's amount parameter must match the transaction's msg.value parameter",
              "key": "C"
            },
            {
              "content": "The deposit() method's amount parameter may or may not match the transaction's msg.value parameter",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "82214e78-253d-4fbc-bb56-fcd4dd805de8",
          "type": "SingleChoice",
          "content": "Which method allows the user's deposit to be used as collateral?",
          "hint": "NoHint",
          "explanation": "setUserUseReserveAsCollateral() allows the user's deposit to be used as collateral. Users will only be able to disable deposits that are not being used as collateral at the time.",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "functions-1"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "deposit()",
              "key": "A"
            },
            {
              "content": "setUserUseDepositAsCollateral()",
              "key": "B"
            },
            {
              "content": "setUserReserveAsCollateral()",
              "key": "C"
            },
            {
              "content": "setUserUseReserveAsCollateral()",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f8891660-96d9-4b5c-94fb-5d9c611815ee",
          "type": "MultipleChoice",
          "content": "Which of the following statements about the repay() method is/are correct?",
          "hint": "NoHint",
          "explanation": "repay() method is used to repay a borrowed asset in whole or in part. The _onBehalfOf parameter can be used to repay a different user's debt. When a third-party repays another user's debt on their behalf, the third-party address must approve() the LendingPoolCore contract (which is separate from the LendingPool contract) with the _amount of the underlying ERC20 of the _reserve contract.",
          "answerKeys": [
            "B",
            "C"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A borrowed asset has to be repaid in whole",
              "key": "A"
            },
            {
              "content": "A borrowed asset can be repaid in whole or in part",
              "key": "B"
            },
            {
              "content": "A third-party can repay another user's debt on their behalf",
              "key": "C"
            },
            {
              "content": "A third-party can not repay another user's debt on their behalf",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7c65668d-8b7b-4de9-8bd9-33736175bb18",
          "type": "SingleChoice",
          "content": "Which method changes the borrow rate modes of the msg.sender from stable to variable?",
          "hint": "NoHint",
          "explanation": "swapBorrowRateMode() changes the borrow rate modes of the msg.sender from stable to variable. rebalanceStableBorrowRate() rebalances the stable rate of _user",
          "answerKeys": [
            "D"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "rebalanceStableBorrowRate()",
              "key": "A"
            },
            {
              "content": "rebalanceBorrowRateMode()",
              "key": "B"
            },
            {
              "content": "swapStableBorrowRate()",
              "key": "C"
            },
            {
              "content": "swapBorrowRateMode()",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ecad25a7-bbdf-47cf-a062-325e8624ace5",
          "type": "SingleChoice",
          "content": "What happens when a liquidation is completed successfully?",
          "hint": "NoHint",
          "explanation": "When the liquidation is completed successfully, the position's health factor is enhanced, bringing it above 1. It does not affect the close factor.",
          "answerKeys": [
            "A"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The position's health factor is enhanced, bringing it above 1",
              "key": "A"
            },
            {
              "content": "The position's health factor is diminished, bringing it below 1",
              "key": "B"
            },
            {
              "content": "The close factor is enhanced, bringing it above 1",
              "key": "C"
            },
            {
              "content": "The close factor is diminished, bringing it below 1",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "48ffb9d9-108c-41e3-9a05-632b49b71d9b",
          "type": "MultipleChoice",
          "content": "What is the close factor?",
          "hint": "NoHint",
          "explanation": "A close factor determines how much collateral a liquidator can close. The current close factor is 0.5. In other words, liquidators can only liquidate up to 50% of the amount owing in a position. This is the amount of the liquidation discount.",
          "answerKeys": [
            "C",
            "D"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "The ratio of total collateral multiplied by the liquidation threshold to borrowed principal",
              "key": "A"
            },
            {
              "content": "The maximum borrowing capacity of a particular collateral",
              "key": "B"
            },
            {
              "content": "Determines how much collateral a liquidator can close",
              "key": "C"
            },
            {
              "content": "It is the amount of the liquidation discount",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "26144fd7-a1ae-44c4-b70f-dc6cc578ea87",
          "type": "SingleChoice",
          "content": "What value of the purchaseAmount parameter can be set to proceed with the largest liquidation allowed by the close factor?",
          "hint": "NoHint",
          "explanation": "purchaseAmount parameter can be set to uint(-1) and the protocol will proceed with the largest liquidation allowed by the close factor.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "functions-2"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "uint(1)",
              "key": "A"
            },
            {
              "content": "uint(-1)",
              "key": "B"
            },
            {
              "content": "uint(10)",
              "key": "C"
            },
            {
              "content": "uint(-10)",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f355a01c-c3d1-41f3-9685-c65d64b16926",
          "type": "MultipleChoice",
          "content": "Select the correct statement(s) about Flash loans.",
          "hint": "NoHint",
          "explanation": "Flash Loans are special transactions that allow you to borrow an asset as long as the borrowed amount (plus a fee) is returned before the transaction ends (also called One Block Borrows). These transactions do not necessitate the provision of collateral by the user prior to the transaction.",
          "answerKeys": [
            "A",
            "B"
          ],
          "subTopics": [],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "key": "A",
              "content": "Flash loans are also called One Block Borrows"
            },
            {
              "key": "B",
              "content": "Borrowed amount has to be returned in the same transaction"
            },
            {
              "key": "C",
              "content": "There is no need to pay fees"
            },
            {
              "key": "D",
              "content": "User has to provide collateral prior to the transaction"
            }
          ]
        },
        {
          "uuid": "c535ee8a-5ac8-47bf-8404-30138aae06f6",
          "type": "SingleChoice",
          "content": "Which of the following is the fee received by LP?",
          "hint": "NoHint",
          "explanation": "Fee to LP = FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL, Fee to Protocol = FLASHLOAN_PREMIUM_TO_PROTOCOL",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "functions-3"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "FLASHLOAN_PREMIUM_TO_PROTOCOL",
              "key": "A"
            },
            {
              "content": "FLASHLOAN_PREMIUM_TOTAL",
              "key": "B"
            },
            {
              "content": "FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL",
              "key": "C"
            },
            {
              "content": "FLASHLOAN_PREMIUM_TOTAL + FLASHLOAN_PREMIUM_TO_PROTOCOL",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "7441eb5f-68f3-40de-b12f-80dc17c80b2c",
          "shortTitle": "V2 Contracts",
          "details": "This video enables learners to know about\n  * AAVE\n  * Main protocol features\n  * What's new in v2 protocol\n  * Resources\n",
          "title": "Introduction to AAVE V2 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=AMAMvKc-O2s",
          "subTopics": []
        },
        {
          "uuid": "8b2485fe-7a9b-4dee-9e65-348c1dc7a66c",
          "shortTitle": "V3 contracts",
          "details": "This video enables learners to know about\n  * AAVE v3 features\n  * Build on top of AAVE\n",
          "title": "Introduction to AAVE V3 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=LzaS8IiqnPY",
          "subTopics": []
        }
      ],
      "summaries": [
        {
          "title": "Introduction",
          "shortTitle": "Introduction",
          "key": "aave-smart-contracts-intro",
          "details": "* Aave is a decentralized finance protocol that facilitates lending and borrowing of cryptocurrency tokens usAave ing diverse algorithms and smart contracts without the presence of centralized intermediaries. \n* It is a non-custodial liquidity protocol that allows users to participate as depositors or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an overcollateralized manner.\n* The participants lending the tokens get interest on their loan and the participants borrowing the tokens pay interest. \n* An individual can lend and borrow simultaneously via Aave.\n* The working mechanism of Aave involves allocating a platform specific token, called aTokens to a user's crypto investment. This is what lenders get when they deposit their assets into the pool.\n* For instance, a user who deposits Ethereum in Aave will hold aETH on Aave. \n* aToken is based on a particular crypto asset and the interest rate each aToken earns is specific to the token deposited, depending on the supply and demand for the original coin.\n\n* Aave has a smart contract based working mechanism wherein the interest rates are determined by different algorithms.\n* The depositors lend the funds in the liquidity pools and earn interest, similarly borrowers can borrow the funds from the liquidity pools. \n* The interest rate for both borrowers and lenders is decided algorithmically:\n* **Interest rate for Borrowers**: The interest rate to be paid by the borrowers depends on the cost of money and the amount of funds available in the pool at a specific time.The amount of funds present in the pool has an inverse relationship with the interest rate. As funds are borrowed from the pool, the amount of funds available decreases which raises the interest rate. \n* **Interest rate for Lenders**: The interest rate received by the lenders corresponds to the earn rate, with the algorithm safeguarding a liquidity reserve to guarantee withdrawals at any time.\n\n* Since cryptocurrency is highly volatile, borrowing in Aave demands overcollateralization. \n* A liquidation event happens when the price of the collateral drops below the liquidation threshold.\n"
        },
        {
          "title": "Important Tech Terms",
          "shortTitle": "Tech Terms",
          "key": "terminology",
          "details": "* **APY**: Annual Percentage Yield is the yield/interest after a year, including compounding interest. This differs from the Annual Percentage Rate (APR), which does not account for compounding effects.\n\n* **Liquidity Index**: The reserve's interest accumulation during the time span since the last updated timestamp.\n\n* **Loan To Value**: The maximum borrowing capacity of a particular collateral. If a collateral has a Loan to Value of 75%, the user will be allowed to borrow 0.75 ETH of primary currency for every 1 ETH of collateral. The Loan To Value is represented in percentage points and is set per collateral.\n\n* **Liquidation Threshold**: The amount of a borrow position that must be liquidated because it is undercollateralized. When a collateral has an 80% liquidation threshold, it signifies that the loan will be liquidated when the debt value equals 80% of the collateral value. The liquidation threshold is defined in percentage points and is specified per collateral.\n\n* **Liquidation Bonus**: The bonus paid to liquidators to encourage the purchase of specified collateral with a health factor less than one. The Liquidation Bonus is defined in percentage points and is determined per collateral.\n\n* **Health factor**: The ratio of total collateral multiplied by the liquidation threshold to borrowed principal. When the Health Factor falls below one, the loan is considered undercollateralized and can be liquidated.\n\n* **Stable rate**: A loan with a stable rate behaves like a fixed rate loan in the short term, but the rates can be rebalanced in the medium/long term in response to rapid market movements.\n\n* **Reserve** : Reserves are the underlying assets' ERC-20 contracts.\n"
        },
        {
          "title": "Released Versions",
          "shortTitle": "Versions",
          "key": "versions",
          "details": "* Aave has released three versions (v1, v2 and v3) as of now and the Governance token of Aave is \"AAVE\". Version 1 or v1 is the base version launched in 2017 and then there have been upgrades with multiple new features added. \n* Aave v2 improves on many areas of v1. Some of the changes are:\n  - There is no longer a LendingPoolCore contract in Aave v2 that retains all of the protocol's assets. Assets are held directly in the linked aToken contracts, with the LendingPool contract serving as the protocol's \"core.\"\n  - Almost all actions in Aave v2 should be executed via the LendingPool contract. This differs from v1, when a redemption/withdrawal of aTokens required a call on the aToken contract.\n  - After depositing collateral into the protocol, a user can easily delegate credit to any address by using approveDelegation() on the relevant debt token.\n  - Flash loans are possible inside the Aave v2 protocol. Indeed, they are widely utilised within the protocol for position switching and other 'trading'-like functions.\n  - Flash loans can now be executed in batches, which means that many flash loans with varied parameters can be performed in the same call. This opens the door to strong new use cases, such as repaying numerous assets and positions with a single flash loan transaction.\n  - You can now do a combination of 'conventional' flash loans that are paid back instantly and flash loans that incur debt (i.e. the flash loan is not paid back immediately).\n  - AddressesProviders will be numerous in multiple markets. The AddressesProviderRegistry will keep track of all Aave market address providers.\n  - LendingPoolCore has been decommissioned. Only LendingPool is used, which simplifies integrations and Aave v2 development.\n* The v3 improved features enable new use cases, sparking a flood of innovation from users and developers. Aave V3 generates I mprovements in all of the these areas - capital efficiency, security, decentralisation, and UX - while simultaneously delivering new functions to harness the capabilities of rollups and the developing ecosystem of rival L1s.\n  - Portal is a new set of core functionalities that can be utilised to enable provided assets to move easily between Aave markets on different networks. On the surface, the feature is fairly simple: the protocol uses the aTokens' unique pegged design to burn aTokens on the source network while minting them on the destination network.\n  - Borrowers can use High Efficiency Mode (E-Mode) to get the most borrowing power out of their collateral. Borrowers can use E-Mode to limit their borrowing to only assets in a specific category (e.g., stablecoins).\n  - One of the most important areas for improvement is managing the inherent complexities of risk exposure modulation.\n  - Repay with aTokens: Allows borrowers to repay with aTokens rather than the underlying asset.\n  - Despite all of the new features, the overall gas cost of all functions fell by about 25%.\n  - Smart contract re-engineering has considerably reduced code size (leaving more room for future revisions) by up to 100K optimizer runs!\n  - All token transfer functions (supply, repay) now support EIP 2612 authorization (this is especially important for L2).\n  - Signature on EIP 712 for credit delegation (no need for contracts to request a user transaction anymore).\n"
        },
        {
          "title": "Protocol Overview",
          "shortTitle": "Overview",
          "key": "overview",
          "details": "* Below image provides an overview of the protocol.\n\n![Architecture](https://github.com/DoDAO-io/dodao-aave-developer-1-course/blob/6bd13f67bbb027bc58280c103f78b0b29d5ad810/images/architechture.png?raw=true)\n`Reference: https://docs.aave.com/developers/v/2.0/the-core-protocol/protocol-overview`\n\n* On Github, the Aave Protocol repository can be found here: https://github.com/aave/\n\n#### Main Contracts\nThe main contracts in Aave and their purposes are:\n* LendingPool: The main entry point into the Aave Protocol. Most interactions with Aave will happen via the LendingPool, including:\n  - deposit()\n  - borrow()\n  - repay()\n  - swapBorrowRateMode()\n  - setUserUseReserveAsCollateral()\n  - withdraw()\n  - flashloan()\n  - liquidationCall()\n* LendingPoolAddressesProvider: The protocol's primary addresses register for specific marketplaces. The most recent contract addresses should be obtained from this contract by making the necessary calls.\n* LendingPoolAddressesProviderRegistry: Contains a list of active LendingPoolAddressesProvider addresses, for different markets.\n* aTokens: The yield-producing, tokenized deposits that are used throughout the Aave protocol. They implement, with minor modifications, the majority of the standard EIP-20/ERC20 token methods, as well as Aave-specific methods such as:\n  - scaledBalanceOf()\n  - getScaledUserBalanceAndSupply()\n  - scaledTotalSupply()\n  All aTokens also implement EIP-2612, which via the permit() function enables gas-less transfers and single transaction approve + actions.\n* Stable and Variable Debt Tokens: The Aave protocol employs tokenised borrow locations throughout. Because debt tokens are non-transferable, most common EIP-20/ERC20 techniques are disabled.\n"
        },
        {
          "title": "AAVE Functionalities in Details - I",
          "shortTitle": "Functions - I",
          "key": "functions-1",
          "details": "* The LendingPool contract is the protocol's principal contract. It exposes all user-oriented operations that may be performed with the Solidity or web3 libraries. The source code is available [here](https://github.com/aave/aave-protocol/blob/master/contracts/lendingpool/LendingPool.sol).\n\n#### Deposit/Lending\n* Lenders share the interest payments made by borrowers based on the utilization rate multiplied by the average borrowing rate. The yield for depositors increases as reserve utilization increases.\n* Lenders are also entitled to a portion of the Flash Loan fees, equal to 0.09% of the Flash Loan volume.\n* There is no minimum or maximum deposit amount; you may deposit any amount you choose.\n\n#### Methods\n#### deposit()\n**function deposit( address _reserve, uint256 _amount, uint16 _referralCode)**\n* Deposits a certain _amount of an asset specified by the _reserve parameter.\n* In exchange, the caller receives a specific number of aTokens. aTokens can be redeemed for the underlying token in a 1:1 ratio.\n* When depositing an ERC-20 token, the LendingPoolCore contract (not the LendingPool contract) must have the required allowance of _amount for the underlying ERC20 of the _reserve asset via approve().\n\n**ETH deposits**\n* Because the protocol does not employ an EIP-20 wrapper like wETH for ETH deposits, the deposit() method's amount parameter must match the transaction's msg.value parameter and be included in your deposit() call.\n* E.g: lendingPool.deposit{ value: msg.value }(reserve, msg.value, referralCode)\n* Because ETH is utilised directly in the protocol (rather than an abstraction like WETH), we use a dummy address to represent it: 0xEeeeeEeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n\n**ERC20 deposits**\n* The _reserve parameter corresponds to the underlying asset's ERC20 contract address.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L753\n\n* The deposit() flow within the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH4HvCIm09jkjFv%2Flending%20pool%20deposit.png?alt=media&token=c92f8256-9d73-41a1-9e96-a3d807425d08)\n \n#### setUserUseReserveAsCollateral()\n**function setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral)**\n* Allow the user's deposit to be used as collateral. Users will only be able to disable deposits that are not being used as collateral at the time.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L341 \n\n**Stable vs Variable Interest Rate**\n* In the short-term, stable rates function as a fixed rate, but they can be rebalanced in the long run in reaction to alterations in the market environment. \n* Depending on supply and demand in Aave, the variable rate can change.\n* The stable rate is the better choice for forecasting how much interest you will have to pay because, as its name suggests, it will remain fairly stable. The variable rate changes over time and, depending on market conditions, could be the optimal rate.\n"
        },
        {
          "title": "AAVE Functionalities in Details - II",
          "shortTitle": "Functions - II",
          "key": "functions-2",
          "details": "#### Borrow\n* You must deposit any asset to be used as collateral before borrowing.The amount you can borrow depends on the value you have deposited and the readily available liquidity.For instance, if there isn't enough liquidity or if your health factor (minimum threshold of the collateral = 1, below this value, liquidation of your collateral is triggered) prevents it, you can’t borrow an asset. The loan is repaid with the same asset that you borrowed.\n* For instance, if you borrow 1 ETH, you'll need to pay back 1 ETH plus interest.\n* In the updated Version 2 of the Aave Protocol, you can also use your collateral to make payments. You can borrow any of the stablecoins like USDC, DAI, USDT, etc. if you want to repay the loan based on the price of the USD.\n\n#### Methods\n#### borrow()\n**function borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode)** \n* Transfers a certain amount of the asset identified by the _reserve parameter to the msg.sender, provided the caller has deposited enough collateral to fund the borrow in advance.\n* Every loan can be opened in either a fixed or variable rate mode. Borrows have an indefinite term and no payback date. In the event of market swings, a borrow position is liquidated if the collateral price falls below a specific threshold. Please read the White Paper to learn more about the stable rate economy.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L219 \n\n* The borrow() flow within the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH3GOEvYvbizwHC%2Flending%20pool%20borrow.png?alt=media&token=2031b536-733e-4a8a-866c-23c86706e641)\n\n#### repay()\n**function repay( address _reserve, uint256 _amount, address payable _onBehalfOf)**\n* Repay a borrowed asset in whole or in part. The _onBehalfOf parameter can be used to repay a different user's debt.\n* When a third-party repays another user's debt on their behalf, the third-party address must approve() the LendingPoolCore contract (which is separate from the LendingPool contract) with the _amount of the underlying ERC20 of the _reserve contract.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L249 \n\n* The repay() flow within the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH9NighH7i_73lI%2Flending%20pool%20repay.png?alt=media&token=cb6e102e-222b-412a-92f0-763ae34e7cce) \n \n#### swapBorrowRateMode()\n**function swapBorrowRateMode(address _reserve)**\n* Changes the borrow rate modes of the msg.sender from stable to variable.\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L326 \n\n#### rebalanceStableBorrowRate()\n**function rebalanceStableBorrowRate(address _reserve, address _user)**\n* Rebalances the stable rate of _user\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L336 \n\n* The rebalance flow for stable rates in the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH7rY4WFE5jRwrB%2Flending%20pool%20rebalancing.png?alt=media&token=8a442d62-6087-4adf-b27b-163478547f79)  \n\n#### liquidationCall()\n**function liquidationCall(address _collateral, address _reserve, address _user, uint256 _purchaseAmount, bool _receiveaToken)**\n* Positions with a health factor less than one should be liquidated.\n* When a position's health factor falls below one, liquidators repay part or all of the outstanding borrowed amount on behalf of the borrower in exchange for a discounted quantity of collateral (sometimes known as a liquidation \"bonus\"). \n* Liquidators have the option of receiving an equal quantity of collateral aTokens or the underlying asset directly. \n* When the liquidation is completed successfully, the position's health factor is enhanced, bringing it above 1.\n* A close factor determines how much collateral a liquidator can close. The current close factor is 0.5. In other words, liquidators can only liquidate up to 50% of the amount owing in a position. This is the amount of the liquidation discount.\n* Liquidators must approve() the LendingPoolCore contract (which is distinct from the LendingPool contract) in order to use the underlying ERC20 of the _reserve asset for the liquidation.\n* **NOTE**: In most cases, profitable liquidators will choose to liquidate as much of the _user position as possible.\n* purchaseAmount parameter can be set to uint(-1) and the protocol will proceed with the largest liquidation allowed by the close factor.\n* For ETH liquidations, the transaction's msg.value should be identical to the _purchaseAmount parameter.\n* To determine a user's health factor, use getUserAccountData().\n* Code: https://github.com/aave/aave-v3-core/blob/f3e037b3638e3b7c98f0c09c56c5efde54f7c5d2/contracts/protocol/pool/Pool.sol#L360 \n\n* The liquidation flow in the protocol is available [here](https://2799188404-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-M3C77KySce4HXyLqkEq%2F-M3Gt4qcUdOm3jNNgZ3O%2F-M3GtjH6dX0q9LDXBn9X%2Flending%20pool%20liquidation.png?alt=media&token=6701e381-1fd1-42ce-919b-39da57434c57)\n"
        },
        {
          "title": "AAVE Functionalities in Details - III",
          "shortTitle": "Functions - III",
          "key": "functions-3",
          "details": "* Flash Loans are special transactions that allow you to borrow an asset as long as the borrowed amount (plus a fee) is returned before the transaction ends (also called One Block Borrows). \n* These transactions do not necessitate the provision of collateral by the user prior to the transaction.\n* To use this feature, you must have a solid understanding of EVM, programming, and smart contracts. To do a Flash Loan, you must first create a contract requesting a Flash Loan. The contract must follow the instructions and repay the loan plus interest and fees in the same transaction.\n\n* Aave v3 provides two flash loan options:\n  - **flashLoan**: Allows the borrower to obtain liquidity from various reserves in a single flashLoan transaction. In this instance, the borrower has the option of opening a stable or variable rate debt position backed by supplied collateral or credit delegation.\n  - **NOTE**: For qualified flashBorrowers, the loan charge is waived (managed by ACLManager)\n  - **flashLoanSimple**: Allows the borrower to access a single reserve of liquidity for the transaction. In this situation, the flash loan fee is not waived, and the borrower is not permitted to open any debt positions at the conclusion of the transaction. For individuals attempting to take advantage of a simple flash loan with a single reserve asset, this strategy is gas efficient.\n\n#### Flow of Execution\n* A helpful mental model to consider when creating your solution for developers:\n  - Your contract contacts the Pool contract and requests a Flash Loan for a specific amount(s) of reserve(s) using flashLoanSimple() or flashLoan() ().\n  - The Pool sends the requested amounts of reserves to your contract after some sanity checks, then executes executeOperation() on the receiver contract.\n  - Your contract now does any arbitrary operation in its code while holding the flash borrowed amount(s).\n  - When you finish your code for a flashLoanSimple, you approve Pool for the flash loaned amount + charge.\n  - If you are executing flashLoan, then all reserves must be granted for flash borrowed amount + fee or adequate collateral or credit delegation must be provided to start debt position, based on the interestRateMode passed for the asset.\n  - If the amount owed is not available (due to a lack of balance or authorisation, or insufficient debt collateral), the transaction is reverted.\n  - All of the preceding occurs in a single transaction (hence in a single ethereum block).\n\n#### Flash Loan Applications\n* Aave Flash Loans are already used for the liquidity swap functionality in Aave V3. Other real-world instances include: arbitrage between assets without requiring the main amount to be present.\n* Liquidating borrow positions without having to repay the debt of the positions and paying off flashLoan amount + charge with discounted collateral claimed.\n\n#### Fee for a Flash loan\n* The flash loan charge is set to 0.09% at deployment and can be changed via Governance Vote. To obtain the current value, use FLASHLOAN PREMIUM TOTAL.\n* The LPs (liquidity providers) and the protocol treasury can split the flashloan charge. The FLASHLOAN PREMIUM TOTAL variable represents the total charge paid by borrowers, which includes:\n* Fee to LP: FLASHLOAN_PREMIUM_TOTAL - FLASHLOAN_PREMIUM_TO_PROTOCOL\n* Fee to Protocol: FLASHLOAN_PREMIUM_TO_PROTOCOL\n* At initialization, FLASHLOAN_PREMIUM_TO_PROTOCOL is 0.\n\n#### First step: Setting Up\n* By implementing the relevant executeOperation() function, your contract that receives the amounts from flash loans must comply with the IFlashLoanSimpleReceiver.sol or IFlashLoanReceiver.sol interface.\n* Additionally, keep in mind that since the owing sums will be deducted from your contract, your contract must let the Pool to deduct those monies in order to repay the flash loan amount plus premiums.\n\n#### Second Step: Calling flashLoan() or flashLoanSimple()\n* To invoke either of the Pool's two flash lending methods, we must provide the necessary parameters. There are three possibilities.\n  - From an EOA ('normal' Ethereum account)\n    - To use an EOA, send a transaction to the appropriate Pool and use the flashLoan() or flashLoanSimple() functions. For parameter information, see the Pool API documentation, making sure to use your contract address from step 1 for the receiverAddress.\n  - From a different contract\n    - As with transmitting a transaction from an EOA, make sure the receiverAddress matches your contract address from step 1.\n  - From the same contract\n    - Utilize address(this) for the receiverAddress parameter in the flash loan method if you wish to use the same contract as in step 1.\n* **Note**: Never keep funds permanently on your FlashLoanReceiverBase contract as they could be exposed to a ['griefing' attack](https://ethereum.stackexchange.com/a/92457/19365), where the stored funds are used by an attacker.\n\n#### Final Step: Completing the flash loan\n* If you used flashLoanSimple() or interestRateMode=0 in flashLoan() for any of the assets in the modes parameter, you will need to repay the flash loaned amounts once you have completed your logic with the flash loaned assets (in your executeOperation() method).\n  - Repaying a flash loaned asset\n    - Check that your contract includes the appropriate amount + premium to repay the borrowed asset. This can be calculated by adding the relevant entries in the amounts and premiums array given to the executeOperation() function. \\\n    - You are not required to return the owing sum to the Pool. The cash will be automatically withdrawn at the end of your operation.\n  - Getting into debt (i.e. not immediately paying back)\n    - If you used mode=1 or mode=2 for any of the assets in the modes parameter, the address put in for onBehalfOf will incur the obligation if the onBehalfOf address previously authorised the msg.sender to incur debts on their behalf.\n    - This means that you can have some assets that are promptly paid back while others incur debt.\n"
        }
      ]
    },
    {
      "title": "Fetch and Show AAVE Data",
      "key": "fetching-aave-data",
      "details": "This chapter talks about how you can fetch real time and time series data from AAVE and show it on the UI. It begins with an introduction to Aave, then contiues with the Graph & GraphQL and we further discuss about the Aave subgraphs. Then we learn how to query Aave's GraphQL database using React and implement a Pie chart too. Then we look on to few example graphql queries. Later on we discuss about the historical rest data and how we can use it to implement a time series graph in react.\n",
      "order": 1,
      "explanations": [
        {
          "title": "Introduction",
          "shortTitle": "Introduction",
          "key": "aave-data-intro",
          "details": "AAVE is a DeFi protocol that facilitates the lending and borrowing of cryptocurrency tokens using diverse algorithms and smart contracts without centralized intermediaries. \nIt is a non-custodial liquidity protocol that allows users to participate as lenders or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an overcollateralized manner.\nAave's GraphQL data layer is a great resource for developers, allowing developers to access data that may not have been available otherwise. This way developers can work with more data and create more advanced applications. \nJust like any decentralized blockchain application, Aave's data can be classified into three types: \n- **Real-time data or current information** - This includes the current state and the new events. With real-time data, you can use data visualisations that reflect changes as they occur in real-time. This means that dashboards are interactive and accurate at any given moment.\n- **Historical** - This includes past state and events. With historical data, you can get a snapshot of information displayed in a chart.\n\nAs discussed above, there are multiple use cases of this data provided by Aave and varied applications (including read-only as well as read/write applications) can be built on top of it and we can examine this data to gain insights on how to update and continue to improve the application.\n\nThe focus of this chapter will be to use Aave's data and show it on the UI in a couple of use cases. \n- Creating a pie graph to review the aave treasury in USDT \n- Implementing a time series graph of how the holdings of different pools have changed over time.\n\nBefore moving on to the code, let's have a look at the importance of analytics.\n\n**Importance of Analytics**\n- Make informed decisions\n- Improve efficiency\n- Identify frauds\n- Improve protocol governance\n- Accelerate through uncertainty\n- Tackle bugs and problems\n- Transform raw data into more valuable information\n\nAave's data can be queried in the form of REST or GraphQL. Aave uses “The Graph” to index its data and anyone can query the subgraphs to get access to this information.\n"
        },
        {
          "key": "graphql",
          "title": "Realtime GraphQL Data",
          "shortTitle": "Realtime Data",
          "details": "#### The Graph and GraphQL\nThe Graph is a decentralized protocol for indexing and querying data from Ethereum-based blockchains. That is, obtaining specific data from the blockchain is a more convenient approach while adhering to the web3 ethos and benefiting from decentralization and stability.\n\nThe underlying query language used in The Graph is GraphQL. What is the distinction between RESTFUL API calls and GraphQL calls? Traditional APIs, on the other hand, require developers to define unique endpoints for users that return specified data. If the user requires further information, they may need to make repeated API calls, potentially hundreds of API calls, to obtain it. As long as the developer has established a flexible schema, The Graph (which uses GraphQL) just requires one call to a subgraph.\nSee this [GraphQL primer](https://medium.com/graphprotocol/graphql-will-power-the-decentralized-web-d7443a69c69a) for additional information on The Graph and the underlying GraphQL.\n\n#### Source of Aave Subgraphs\nTo view the source of the subgraphs, see our [Github repo](https://github.com/aave/protocol-v2-subgraph).\n\nProduction Network: [Polygon](https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-polygon)\n\n#### How to Make Use of the Playground\n\n- If you use your browser to navigate to the above playground links, you will be directed to The Graph's playground, where you can simply write and test GraphQL queries.\n- Select the purple play button to run your query.\n- In the middle column, the query results will be returned.\n- Use the 'Schema' column on the right to see what data is available, which may be investigated to discover the underlying data.\n- You can also type in the left column and use the auto-complete feature to identify the appropriate query/types.\n\n#### Points to keep in mind\n- All address values (for example, when used for id) must be in lowercase.\n- In lowercase, the ID of reserves is the asset's address and the address of the market's LendingPoolAddressProvider.\n- When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).\n- By default, each 'page' of results returns 100 entries. This is expandable to a maximum of 1000 entries per page.\n- To list the following 1000 entries, for example, put something like: (skip:1000, first: 1000) to your query's arguments.\n- This is also true for nested entries, such as arrays.\n\nThis Graph endpoint contains only static data. To obtain a user's most recent balance (including interest earned up to that moment), you must either compute it yourself or make a balanceOf() call to the aToken contract.\n\n| Return Data Type           | Subgraph Address                                                       |\n| -------------------------- | ---------------------------------------------------------------------- | \n| Mainnet                    | https://thegraph.com/explorer/subgraph/aave/aave-v2-matic              |\n| Görli (Goerli) Testnet     | https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-goerli   |\n\nGoerli is an Ethereum test network that allows blockchain development testing prior to deployment on the main Ethereum network, Mainnet. Görli (Goerli) Testnet is the first proof-of-authority cross-client testnet, synching Parity Ethereum, Geth, Nethermind, Hyperledger Besu (formerly Pantheon), and EthereumJS. This testnet is a community-based project, completely open-source, naturally. It was born in September 2018 during ETHBerlin and has been growing in contributors ever since.\n\n#### Using your app to access GraphQL data\n\nThe preferred method is to utilize a client library that can handle the 'plumbing' to ensure you have up-to-date data (with caching sometimes included). Apollo is used internally, but there are several choices depending on your programming language; read the official GraphQL page for more information.\nIf you are unable to utilize a client library (for example, while querying using Postman), you can send a POST request to our subgraph's HTTP endpoint with the header: \"Content-Type: application/json\" and the body comprising of your query on one line in quotations. As an example:\n```\n{\"query\": \"{ reserves (where: {usageAsCollateralEnabled: true})  { id name price {id} liquidityRate variableBorrowRate stableBorrowRate}}\" }\n```\n\n"
        },
        {
          "key": "react-app",
          "title": "Querying Aave's GraphQL database using React and implementing a Pie chart",
          "shortTitle": "Display Liquidity",
          "details": "* **Initial Setup**<br/>\n  First, let's create a React project, you can refer [this](https://create-react-app.dev/docs/getting-started/) documentation.\n  ```shell\n    npx create-react-app aave-analytics-sample-app\n  ```\n  Run npm start to check if the project runs fine.\n\n* **Integrate ApolloClient**<br/>\n  Let's integrate the Apollo client library. We can install and setup the client using [this](https://www.apollographql.com/docs/react/get-started/) documentation.\n  ```shell\n    npm install @apollo/client graphql\n  ```\n  We can use the sample code to fetch the data and test our setup.\n\n* **Initialize the ApolloClient**<br/>\n  With our dependencies already set up, we can now create an ApolloClient instance.\n  Let's start by importing the symbols we require from @apollo/client into index.js:\n  ```javascript\n    import { ApolloClient, InMemoryCache, ApolloProvider, gql } from '@apollo/client';\n  ```\n  Next, we'll initialize ApolloClient by handing it a configuration object including the uri and cache fields:\n  ```javascript\n    const client = new ApolloClient({\n      uri: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-goerli',\n      cache: new InMemoryCache(),\n    });\n  ```\n\n* **Connect the client to React**<br/>\n  We can connect Apollo Client to React with the ApolloProvider component. Similar to React's Context.Provider, ApolloProvider wraps our React app and places Apollo Client on the context, enabling us to access it from anywhere in our component tree.\n\n  In index.js, let's wrap our React app with an ApolloProvider\n  ```javascript\n    import React from 'react';\n    import * as ReactDOM from 'react-dom/client';\n    import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';\n    import App from './App';\n\n    const client = new ApolloClient({\n      uri: 'https://api.thegraph.com/subgraphs/name/aave/protocol-v3-goerli',\n      cache: new InMemoryCache(),\n    });\n\n    const root = ReactDOM.createRoot(document.getElementById('root'));\n\n    root.render(\n      <ApolloProvider client={client}>\n        <App />\n      </ApolloProvider>,\n    );\n  ```\n\n* **Fetching data with useQuery**<br/>\n  After the ApolloProvider is hooked up, we can start requesting data with useQuery. The useQuery hook is a React hook that shares GraphQL data with your UI.\n  Switching over to our App.js file, we'll start by replacing our existing file contents with the code snippet below:\n  ```javascript\n    import { useQuery, gql } from '@apollo/client';\n\n    export default function App() {\n    return (\n        <div className=\"App\">\n            <h2 className=\"App-header\">AAVE Analytics</h2>\n            <br/>\n            <DisplayGraphs />\n        </div>\n    );\n    }\n  ```\n  We can define the query we want to execute by wrapping it in the gql template literal:\n  ```graphql\n    const GET_QUERY = gql`\n    {\n        reserves {\n            id\n            symbol\n            name\n      \n            totalLiquidity\n        }\n    }\n    `;\n  ```\n  Next, let's define a component named DisplayGraphs that executes our GET_QUERY query with the useQuery hook:\n  ```javascript\n    function DisplayLocations() {\n      const { loading, error, data } = useQuery(GET_QUERY);\n\n      if (loading) return <p>Loading...</p>;\n      if (error) return <p>Error :(</p>;\n\n      let names = data.reserves.map(a => a.name);\n        let total = data.reserves.map(a => a.totalLiquidity);\n        let utilization = data.reserves.map(a => a.utilizationRate);\n\n        total.forEach((element, index) => {\n            total[index] = element % 10^18;\n        });\n    ….\n    }\n  ```\n\n* **Implementing the Pie Chart**<br/>\n  Now, our aim is to create a pie chart using the data we receive. So now we'll use [react-chartjs-2](https://react-chartjs-2.js.org/).\n  ```\n  npm install --save chart.js react-chartjs-2\n  ```\n  Then we will import it in our App.js:\n  ```\n  import { Pie } from 'react-chartjs-2';\n  ```\n  Now we need to initialize our code to get a Pie chart:\n  ```\n  ChartJS.register(ArcElement, Tooltip, Legend);\n  ```\n\n* Finally we will add the code to get our Pie chart:\n  ```javascript\n    const piedata = {\n            labels: names,\n            datasets: [\n              {\n                label: 'percentage',\n                data: total,\n                backgroundColor: [\n                  'rgba(255, 99, 132, 0.2)',\n                  'rgba(54, 162, 235, 0.2)',\n                  'rgba(255, 206, 86, 0.2)',\n                  'rgba(75, 192, 192, 0.2)',\n                  'rgba(153, 102, 255, 0.2)',\n                  'rgba(255, 159, 64, 0.2)',\n                  'rgba(255, 140, 64, 0.2)',\n                  'rgba(205, 159, 64, 0.2)',\n                ],\n                borderColor: [\n                  'rgba(255, 99, 132, 1)',\n                  'rgba(54, 162, 235, 1)',\n                  'rgba(255, 206, 86, 1)',\n                  'rgba(75, 192, 192, 1)',\n                  'rgba(153, 102, 255, 1)',\n                  'rgba(255, 159, 64, 1)',\n                  'rgba(205, 159, 64, 1)',\n                  'rgba(255, 149, 64, 1)',\n                ],\n                borderWidth: 1,\n              },\n            ],\n        };\n\n    const optionsPieChart = {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'top',\n              },\n              title: {\n                display: true,\n                text: 'Total Liquidity',\n              },\n            },\n        };\n\n      return (\n            <div className=\"Chart-container\">\n                <div className=\"Pie-container\">\n                    <Pie options={optionsPieChart} data={piedata} />\n                </div>\n            </div>\n        );\n  ```\n\n  This will give us a Pie chart in our React app.\n\n  ![Pie Chart](https://raw.githubusercontent.com/DoDAO-io/dodao-aave-developer-1-course/main/images/piechart.png)\n\n  You can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app).\n"
        },
        {
          "key": "graphql-queries",
          "title": "Graphql Queries",
          "shortTitle": "Graphql Queries",
          "details": "\n#### Examples of Queries\n\nWe'll be using the mainnet Big uints GraphQL endpoints in the queries below. These queries can be copied and pasted into the Graph playground links.\n\n##### Reserve Data\nIf we want to receive a list of all the reserves that can be used as collateral, as well as the interest rates for each reserve, we can use the following query:\n```graphql\n{\n  reserves (where: {\n    usageAsCollateralEnabled: true\n  }) {\n    id\n    name\n    price {\n      id\n    }\n    liquidityRate\n    variableBorrowRate\n    stableBorrowRate\n  }\n}\n```\n\nWe would utilise the reserves ERC20 token address to retrieve data for a certain reserve. For the Chainlink reserve, for example:\n\n```graphql\n{\n  reserve(id: \"0x514910771af9ca656af840dff83e8264ecf986ca0x24a42fd28c976a61df5d00d0599c34c4f90748c8\") { // LINK\n    symbol\n    price\n    aToken {\n      id\n    }\n  }\n}\n```\n\nIf we wish to retrieve historical interest rate data for a specific reserve and paginate through the records, our query may look like this:\n```graphql\n{\n  reserve (id: \"0x0000000000085d4780b73119b644ae5ecd22b3760x24a42fd28c976a61df5d00d0599c34c4f90748c8\") { // TUSD\n    id\n    paramsHistory(skip:1000, first: 1000) {\n      id\n      variableBorrowRate\n      utilizationRate\n      liquidityRate\n      timestamp\n    }\n  }\n}\n```\n\n##### User Data\nWhen an address communicates with the Aave Protocol, a UserReserve is generated, with the user ID equal to the user's address plus the reserve's ID (which is the ERC20 token address).\nTo obtain information on a certain UserReserve:\n```graphql\n{\n  userReserve(id: \"USER_ADDRESS_AND_RESERVE_ADDRESS\") {\n    reserve {\n      id\n      symbol\n    }\n    user {\n      id\n    }\n  }\n}\n```\n\nTo retrieve all reserves (i.e. positions) held by a specific user (notice that the user address must be lower case):\n```graphql\n{\n  userReserves(where: { user: \"USER_ADDRESS\"}) {\n    id\n    reserve{\n      id\n      symbol\n    }\n    user {\n      id\n    }\n  }\n}\n```\n\n##### Deposit data\nTo obtain recent deposits for a certain asset:\n```graphql\n{\n  deposits (orderBy: timestamp, orderDirection: desc, where: { \n    reserve: \"0xdac17f958d2ee523a2206206994597c13d831ec70x24a42fd28c976a61df5d00d0599c34c4f90748c8\" // USDT\n  }) {\n    id\n    amount\n    timestamp\n  }\n}\n```\n\n##### Borrow data\nTo obtain recent borrows for a certain asset:\n```graphql\n{\n  borrows (orderBy: timestamp, orderDirection: desc, where: { \n    reserve: \"0xdac17f958d2ee523a2206206994597c13d831ec70x24a42fd28c976a61df5d00d0599c34c4f90748c8\" // USDT\n  }) {\n    id\n    amount\n    timestamp\n  }\n}\n```\n\n##### Flash loan data\nFor instance, consider the following query for analysing the five most recent Flash Loans:\n```graphql\n{ \n  flashLoans( \n    first: 5 \n    orderBy: timestamp \n    orderDirection: desc \n  ) { \n    id \n    reserve { \n      id \n      name \n      symbol \n    } \n    amount \n    totalFee \n    timestamp \n  } \n} \n```"
        },
        {
          "key": "historical-rest-data",
          "title": "Historical Rest Data",
          "shortTitle": "Historical Data",
          "details": "Now we will use the [Aave Protocol API](https://aave-api-v2.aave.com/) to create a time series graph.\nWe will use the same react application to create the time series graph too, so if you still haven't create a react app by following the previous steps.\n\nSince the the [Aave Protocol API](https://aave-api-v2.aave.com/) is for v2 mainnet so now we need to query the Aave v2 mainnet subgraph.\n\nWe need to make the fetch requests from https://aave-api-v2.aave.com/#/data/get_data_rates_history to get the time series data for any Aave reserve. \nIf you visit the above link, you can see that we require a reserveID to fetch the data (there is a sample reserveID already provided in case you want to try it out). So to get this reserveID, we will query the Aave v2 mainnet subgraph (https://thegraph.com/hosted-service/subgraph/aave/protocol-v2 ). We have already queried the reserveIDs for ChainLink Token (`0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5`) and TrueUSD (`0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5`) which we will be using to plot the graph. \n\nIf you want to query the reserveID yourself, you can try this:\n```graphql\n\n  {\n    pools {\n      reserves {\n        id\n        name\n        symbol\n      }\n    }\n  }\n\n```\n\nThis query returns us an array of objects which contains the pools with the reserves id, name and symbol.\n\nAlso, in the GET request we need to provide the start date (from) and time interval (resolutionInHours) to fetch the data. You can use [this](https://www.epochconverter.com/) UNIX timestamp convertor to change the date.\nSo now you can visit the aave protocol api and playaround with different reserveID, from and resolutionInHours.\n"
        },
        {
          "key": "historical-data-continue",
          "title": "Time Series Graph from Historical Rest Data",
          "shortTitle": "React App",
          "details": "\n\nNow, let's visit our App.js and add some changes to code to get our desired graph.\n\n* Let's add some import statements as we need to use Line Chart this time to represent the time series data. So you can update your import statements to the following:\n  ```javascript\n    import React, {useEffect, useState} from 'react';\n    import { useQuery, gql } from '@apollo/client';\n    import { Chart as ChartJS, ArcElement, Tooltip, Legend, CategoryScale, LinearScale, PointElement, LineElement, Title, } from 'chart.js';\n\n    import { Pie, Line } from 'react-chartjs-2';\n    import './App.css';\n\n    ChartJS.register(ArcElement, \n        CategoryScale,\n        LinearScale,\n        PointElement,\n        LineElement,\n        Title,\n        Tooltip,\n        Legend\n    );\n  ```\n\n* Now, we need to fetch the get requests so for that we will use the useEffect hook from React and store the data using useState hook. So add the following code to your DisplayGraphs functions:\n  ```javascript\n    const [linedata1, setLinedata1] = useState([]);\n        const [linedata2, setLinedata2] = useState([]);\n\n        useEffect(() => {\n            Promise.all([\n                fetch('https://aave-api-v2.aave.com/data/rates-history?reserveId=0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5&from=1667952000&resolutionInHours=6'),\n                fetch('https://aave-api-v2.aave.com/data/rates-history?reserveId=0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5&from=1667952000&resolutionInHours=6'),\n            ])\n            .then(([resData1, resData2]) => \n                Promise.all([resData1.json(), resData2.json()])\n            )\n            .then(([data1, data2]) => {\n                console.log(data1, data2);\n                setLinedata1(data1);\n                setLinedata2(data2);\n            })\n            .catch(([err1, err2]) => {\n                console.log(err1.message, err2.message);\n            });\n        }, []);\n  ```\n\n  The Get request also returns some unwanted data and the timestamp is in a format which we don't like much, so let's update it:\n  ```javascript\n    let timestamps = linedata1.map(a => (a.x.year + '/' + a.x.month + '/' + a.x.date + ' ' + a.x.hours + ' hours'));\n        let utilization1 = linedata1.map(a => a.utilizationRate_avg);\n        let utilization2 = linedata2.map(a => a.utilizationRate_avg);\n\n        timestamps.forEach((element, index) => {\n            timestamps[index] = element.toString();\n        });\n  ```\n* Now, let's create the Line chart using the following code:\n```javascript\n    const optionsLineChart = {\n            responsive: true,\n            plugins: {\n              legend: {\n                position: 'top',\n              },\n              title: {\n                display: true,\n                text: 'Avg Utilization Rate',\n              },\n            },\n        };\n  \n    const linedata = {\n        labels: timestamps,\n        datasets: [\n          {\n            label: 'ChainLink Token',\n            data: utilization1,\n            borderColor: 'rgb(255, 99, 132)',\n            backgroundColor: 'rgba(255, 99, 132, 0.5)',\n          },\n          {\n            label: 'TrueUSD',\n            data: utilization2,\n            borderColor: 'rgb(53, 162, 235)',\n            backgroundColor: 'rgba(53, 162, 235, 0.5)',\n          },\n        ],\n    };\n\n    return (\n        <div className=\"Chart-container\">\n            <div className=\"Pie-container\">\n                <Pie options={optionsPieChart} data={piedata} />\n            </div>\n            <div className=\"Line-container\">\n                <Line options={optionsLineChart} data={linedata} />\n            </div> \n        </div>\n    );\n  ```\n\nThis will provide us with the following time series graph:\n![Utilization Rate](https://raw.githubusercontent.com/DoDAO-io/dodao-aave-developer-1-course/main/images/historical.png)\n\nYou can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app).\n"
        }
      ],
      "questions": [
        {
          "uuid": "7e090787-7925-4eda-8acd-fb90dce8582e",
          "type": "MultipleChoice",
          "content": "Select the correct statement(s).",
          "hint": "NoHint",
          "explanation": "RESTFUL APIs require developers to define unique endpoints for users that return specified data. If the user requires further information, they may need to make repeated API calls, potentially hundreds of API calls, to obtain it. As long as the developer has established a flexible schema, The Graph (which uses GraphQL) just requires one call to a subgraph.",
          "answerKeys": [
            "A",
            "B",
            "D"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "RESTFUL APIs require developers to define unique endpoints for users that return specified data.",
              "key": "A"
            },
            {
              "content": "If the user requires further information, they may need to make repeated API calls",
              "key": "B"
            },
            {
              "content": "The Graph requires developers to define unique endpoints for users that return specified data.",
              "key": "C"
            },
            {
              "content": "The Graph just requires one call to a subgraph.",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e2fb2ae0-dc82-454b-988e-ce59d450fe4a",
          "type": "SingleChoice",
          "content": "What is The Graph?",
          "hint": "NoHint",
          "explanation": "The Graph is a decentralized protocol for indexing and querying data from Ethereum-based blockchains.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Centralized protocol for indexing and querying data",
              "key": "A"
            },
            {
              "content": "Decentralized protocol for indexing and querying data",
              "key": "B"
            },
            {
              "content": "Decentralized query language",
              "key": "C"
            },
            {
              "content": "Centralized query language",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "053c742c-3992-42da-abac-719e4260b878",
          "type": "SingleChoice",
          "content": "What happens when an address communicates with the Aave Protocol?",
          "hint": "NoHint",
          "explanation": "When an address communicates with the Aave Protocol, a UserReserve is generated, with the user ID equal to the user's address plus the reserve's ID (which is the ERC20 token address).",
          "answerKeys": [
            "C"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A UserReserve is generated, with the user ID equal to the user's address",
              "key": "A"
            },
            {
              "content": "A UserReserve is generated, with the user ID equal to the reserve's ID",
              "key": "B"
            },
            {
              "content": "A UserReserve is generated, with the user ID equal to the user's address plus the reserve's ID",
              "key": "C"
            },
            {
              "content": "No UserReserve is generated",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "078a4e4e-71e1-4e20-ad13-603502171e6c",
          "type": "MultipleChoice",
          "content": "Pick the correct statement(s) about the Aave's GraphQL queries.",
          "hint": "NoHint",
          "explanation": "All address values (for example, when used for id) must be in lowercase. In lowercase, the ID of reserves is the asset's address and the address of the market's LendingPoolAddressProvider. When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).",
          "answerKeys": [
            "B",
            "D"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "All address values (for example, when used for id) must be in uppercase.",
              "key": "A"
            },
            {
              "content": "All address values (for example, when used for id) must be in lowercase.",
              "key": "B"
            },
            {
              "content": "When utilizing the raw endpoints, the numeric number queried will be returned in wei units (i.e. 10^18) only.",
              "key": "C"
            },
            {
              "content": "When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e950c0e1-a368-471f-8671-cc078c0b7571",
          "type": "SingleChoice",
          "content": "What is Goerli?",
          "hint": "NoHint",
          "explanation": "Goerli is an Ethereum test network that allows blockchain development testing prior to deployment on the main Ethereum network, Mainnet.",
          "answerKeys": [
            "B"
          ],
          "subTopics": [
            "graphql"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Data query language",
              "key": "A"
            },
            {
              "content": "An Ethereum test network",
              "key": "B"
            },
            {
              "content": "A decentralized protocol for indexing and querying data",
              "key": "C"
            },
            {
              "content": "A DeFi protocol",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "7441eb5f-68f3-40de-b12f-80dc17c80b2c",
          "shortTitle": "V2 Contracts",
          "details": "This video enables learners to know about\n  * AAVE\n  * Main protocol features\n  * What's new in v2 protocol\n  * Resources\n",
          "title": "Introduction to AAVE V2 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=AMAMvKc-O2s",
          "subTopics": []
        },
        {
          "uuid": "8b2485fe-7a9b-4dee-9e65-348c1dc7a66c",
          "shortTitle": "V3 contracts",
          "details": "This video enables learners to know about\n  * AAVE v3 features\n  * Build on top of AAVE\n",
          "title": "Introduction to AAVE V3 Smart Contracts",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=LzaS8IiqnPY",
          "subTopics": []
        }
      ],
      "summaries": [
        {
          "key": "aave-data-intro",
          "title": "Introduction",
          "shortTitle": "Introduction",
          "details": "* AAVE is a DeFi protocol that facilitates the lending and borrowing of cryptocurrency tokens using diverse algorithms and smart contracts without centralized intermediaries. \n* It is a non-custodial liquidity protocol that allows users to participate as lenders or borrowers. Depositors provide liquidity to the market to earn a passive income, while borrowers are able to borrow in an over-collateralized manner.\n* Aave's GraphQL data layer is a great resource for developers, allowing developers to access data that may not have been available otherwise. This way developers can work with more data and create more advanced applications. \n* Just like any decentralized blockchain application, Aave's data can be classified into three types: \n  - **Real-time data or current information** - This includes the current state and the new events. With real-time data, you can use data visualisations that reflect changes as they occur in real-time. This means that dashboards are interactive and accurate at any given moment.\n  - **Historical** - This includes past state and events. With historical data, you can get a snapshot of information displayed in a chart.\n\n* There are multiple use cases of this data provided by Aave and varied applications (including read-only as well as read/write applications) can be built on top of it and we can examine this data to gain insights on how to update and continue to improve the application.\n\n* The focus of this chapter will be to use Aave's data and show it on the UI in a couple of use cases. \n  - Creating a pie graph to review the Aave treasury in USDT \n  - Implementing a time series graph of how the holdings of different pools have changed over time.\n\n* **Importance of Analytics**\n  - Make informed decisions\n  - Improve efficiency\n  - Identify frauds\n  - Improve protocol governance\n  - Accelerate through uncertainty\n  - Tackle bugs and problems\n  - Transform raw data into more valuable information\n\n* Aave's data can be queried in the form of REST or GraphQL. Aave uses “The Graph” to index its data and anyone can query the subgraphs to get access to this information.\n"
        },
        {
          "title": "Realtime GraphQL Data",
          "shortTitle": "Realtime Data",
          "key": "graphql",
          "details": "#### The Graph and GraphQL\n* The Graph is a decentralized protocol for indexing and querying data from Ethereum-based blockchains. That is, obtaining specific data from the blockchain is a more convenient approach while adhering to the web3 ethos and benefiting from decentralization and stability.\n\n* The underlying query language used in The Graph is GraphQL. What is the distinction between RESTFUL API calls and GraphQL calls? Traditional APIs, on the other hand, require developers to define unique endpoints for users that return specified data. If the user requires further information, they may need to make repeated API calls, potentially hundreds of API calls, to obtain it. As long as the developer has established a flexible schema, The Graph (which uses GraphQL) just requires one call to a subgraph.\n* See this [GraphQL primer](https://medium.com/graphprotocol/graphql-will-power-the-decentralized-web-d7443a69c69a) for additional information on The Graph and the underlying GraphQL.\n\n#### Source of Aave Subgraphs\n* To view the source of the subgraphs, see our [Github repo](https://github.com/aave/protocol-v2-subgraph).\n\nProduction Network: [Polygon](https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-polygon)\n\n#### How to Make Use of the Playground\n\n* If you use your browser to navigate to the above playground links, you will be directed to The Graph's playground, where you can simply write and test GraphQL queries.\n* Select the purple play button to run your query.\n* In the middle column, the query results will be returned.\n* Use the 'Schema' column on the right to see what data is available, which may be investigated to discover the underlying data.\n* You can also type in the left column and use the auto-complete feature to identify the appropriate query/types.\n\n#### Points to keep in mind\n* All address values (for example, when used for id) must be in lowercase.\n* In lowercase, the ID of reserves is the asset's address and the address of the market's LendingPoolAddressProvider.\n* When utilizing the raw endpoints, the numeric number queried will be returned in either wei units (i.e. 10^18), the decimals of the asset itself (i.e. 10^6 for USDC), or ray units (i.e. 10^27).\n* By default, each 'page' of results returns 100 entries. This is expandable to a maximum of 1000 entries per page.\n* To list the following 1000 entries, for example, put something like: (skip:1000, first: 1000) to your query's arguments.\n* This is also true for nested entries, such as arrays.\n\n* This Graph endpoint contains only static data. To obtain a user's most recent balance (including interest earned up to that moment), you must either compute it yourself or make a balanceOf() call to the aToken contract.\n\n| Return Data Type           | Subgraph Address                                                       |\n| -------------------------- | ---------------------------------------------------------------------- | \n| Mainnet                    | https://thegraph.com/explorer/subgraph/aave/aave-v2-matic              |\n| Görli (Goerli) Testnet     | https://thegraph.com/hosted-service/subgraph/aave/protocol-v3-goerli   |\n\n* Goerli is an Ethereum test network that allows blockchain development testing prior to deployment on the main Ethereum network, Mainnet. Görli (Goerli) Testnet is the first proof-of-authority cross-client testnet, synching Parity Ethereum, Geth, Nethermind, Hyperledger Besu (formerly Pantheon), and EthereumJS. This testnet is a community-based project, completely open-source, naturally. It was born in September 2018 during ETHBerlin and has been growing in contributors ever since.\n\n#### Using your app to access GraphQL data\n\n* The preferred method is to utilize a client library that can handle the 'plumbing' to ensure you have up-to-date data (with caching sometimes included).  Apollo is used internally, but there are several choices depending on your programming language; read the official GraphQL page for more information.\n* If you are unable to utilize a client library (for example, while querying using Postman), you can send a POST request to our subgraph's HTTP endpoint with the header: \"Content-Type: application/json\" and the body comprising of your query on one line in quotations. As an example:\n```\n{\"query\": \"{ reserves (where: {usageAsCollateralEnabled: true})  { id name price {id} liquidityRate variableBorrowRate stableBorrowRate}}\" }\n```\n"
        },
        {
          "key": "historical-rest-data",
          "title": "Historical Rest Data",
          "shortTitle": "Historical Data",
          "details": "* Now we will use the [Aave Protocol API](https://aave-api-v2.aave.com/) to create a time series graph.\n* We will use the same react application to create the time series graph too, so if you still haven't create a react app by following the previous steps.\n* Since the the [Aave Protocol API](https://aave-api-v2.aave.com/) is for v2 mainnet so now we need to query the Aave v2 mainnet subgraph.\n* We need to make the fetch requests from https://aave-api-v2.aave.com/#/data/get_data_rates_history to get the time series data for any Aave reserve. \n* If you visit the above link, you can see that we require a reserveID to fetch the data (there is a sample reserveID already provided in case you want to try it out). So to get this reserveID, we will query the Aave v2 mainnet subgraph (https://thegraph.com/hosted-service/subgraph/aave/protocol-v2 ). We have already queried the reserveIDs for ChainLink Token (`0x514910771af9ca656af840dff83e8264ecf986ca0xb53c1a33016b2dc2ff3653530bff1848a515c8c5`) and TrueUSD (`0x0000000000085d4780b73119b644ae5ecd22b3760xb53c1a33016b2dc2ff3653530bff1848a515c8c5`) which we will be using to plot the graph. \n* We query an array of objects which contains the pools with the reserves id, name and symbol.\n* Also, in the GET request we need to provide the start date (from) and time interval (resolutionInHours) to fetch the data. You can use [this](https://www.epochconverter.com/) UNIX timestamp convertor to change the date.\n* So now you can visit the aave protocol api and playaround with different reserveID, from and resolutionInHours.\n* Now, we visit our App.js and add some changes to code to get our desired graph and add some import statements as we need to use Line Chart this time to represent the time series data.\n* Now, we need to fetch the get requests so for that we will use the useEffect hook from React and store the data using useState hook. So add the following code to your DisplayGraphs functions.\n* The Get request also returns some unwanted data and the timestamp is in a format which we don't like much, so we update it.\n* Finally, we create the Line chart.\n* You can get the complete code [here](https://github.com/DoDAO-io/aava-analytics-sample-app). \n"
        }
      ]
    },
    {
      "title": "Starter-DApp-Template",
      "key": "starter-dapp-template",
      "details": "This chapter discusses about the starter dapp [template](https://github.com/DoDAO-io/dodao-simple-contract-template) in detail. \n",
      "order": 2,
      "explanations": [
        {
          "key": "starter-dapp-template-intro",
          "title": "Introduction",
          "shortTitle": "Introduction",
          "details": "This guide is a detailed walkthrough of how to setup, build, and run a minimal React Dapp using [this template](https://github.com/DoDAO-io/dodao-simple-contract-template) that deploys  and interacts with a simple Solidity smart contract using Hardhat and MetaMask as part of one's development workflow.\n#### What you will be building/running\nThe template finally looks like this:\n![starter-template-image](https://raw.githubusercontent.com/DoDAO-io/dodao-aave-developer-1-course/main/images/starter-template.png)\nThis dapp template is very simple and uses a trivial 'Token' smart contract that allows you to create your own token and also mint it to deployer's address. The deployer can then transfer the tokens to whichever address he likes.\n"
        },
        {
          "key": "stack-overview",
          "title": "Stack Overview",
          "shortTitle": "Stack Overview",
          "details": "#### The stack/tools used in the template\n* Solidity (To write the smart contract) \n* Hardat (Build, test and deployment framework) \n* React (Build the frontend) \n* Ethers (To interact with the blockchain and the smart contract) \n* MetaMask (Wallet browser extension) \n* Alchemy (Node provider)\n#### Overview of the stack\n* [Solidity](https://docs.soliditylang.org/en/v0.8.17/) is a programming language for writing smart contracts that run on the Ethereum platform. It is a high-level language that is easy to read and write, and it is compiled, meaning that the code is converted into a format that is executable by the Ethereum Virtual Machine.  Solidity is a powerful and versatile language for creating smart contracts.\n* [Hardhat](https://hardhat.org/) is a set of tools that facilitates developers in running a local Ethereum development blockchain, writing Solidity smart contract code, running smart contract tests, and debugging Solidity code, all without dealing with live Ethereum blockchain networks. You'll use Hardhat to run your own local Ethereum test network.\n* [React](https://reactjs.org/) is a JavaScript library for building user interfaces. It is designed to make it easy for developers to create complex and dynamic user interfaces,  by breaking them down into small, reusable components. React allows developers to efficiently update the user interface in response to user input or changes in data.  It is widely used by web and mobile developers to create interactive and user-friendly applications.\n* [Ethers.js](https://docs.ethers.org/v5/) is a JavaScript library for working with the Ethereum blockchain.  It provides a simple and intuitive interface for developers to build applications that interact with Ethereum, including support for working with smart contracts, accounts, and transactions.  Ethers.js is widely used by developers building Ethereum applications.\n* [MetaMask](https://docs.metamask.io/guide/) is a browser extension that allows users to interact with the Ethereum blockchain.  It provides a secure and user-friendly way to manage Ethereum accounts, sign transactions, and interact with decentralized applications (DApps) in the browser.  MetaMask also allows users to access the Ethereum mainnet and test networks, such as Goerli, making it easy to switch between networks and test contracts without the need to run a full Ethereum node.\n* [Alchemy](https://www.alchemy.com/) is a blockchain infrastructure and development platform that provides developers with tools and services for building and deploying decentralized applications (dApps) on Ethereum and other networks.  Alchemy offers a suite of nodes, which are nodes on the Ethereum network that are managed and maintained by the Alchemy team.  These nodes provide developers with a reliable and secure connection to the Ethereum network, allowing them to easily interact with dApps and other contracts on the network.\n* [Goerli](https://goerli.net/) is a public, proof-of-authority Ethereum test network that is designed to be a stable and reliable environment for testing and deploying decentralized applications (dApps).  By using Goerli, developers can test their dApps and contracts in a real-world environment without risking any real Ether or other assets.  This allows developers to ensure that their dApps are functioning properly before deploying them to the main Ethereum network.\n* To complete the tutorial, you will need to use the [Git](https://git-scm.com/) command line interface (CLI) tool to download the example code from GitHub. You will also need to install and use Node.js and/or Yarn to build, compile, and run the smart contract and frontend Dapp. You will use a terminal window to run the CLI tools and manage the project.\n"
        },
        {
          "key": "setup",
          "title": "Template Setup",
          "shortTitle": "Setup",
          "details": "### Setup General steps to build a web3 Dapp\nTo create a web3 DApp using Solidity, Hardhat, React, Ethers.js, MetaMask, and the Alchemy node on the Goerli test network, you will need to use the following steps:\n* Set up a development environment for building Ethereum DApps, including installing Node.js, yarn or npm, and the required dependencies for Solidity, Hardhat, React, and Ethers.js. \n* Write a smart contract for the DApp using Solidity. This will involve defining the contract's state variables and functions, and testing them using Hardhat. \n* Compile the contract using Hardhat and solc, and deploy it to the Goerli test network using the Alchemy node. \n* Create the front-end for the DApp using React, and use Ethers.js to interact with the deployed contract. \n* Test the DApp using a testing framework like Mocha or Chai, to ensure that it is working as expected. \n* Publish the DApp to a hosting platform like GitHub Pages or Netlify, and use MetaMask to access it on the web.\n\nOnce the DApp is published, users will be able to interact with the contract on the Goerli test network using their MetaMask-enabled browser,  and they will be able to use the DApp's user interface to send and receive tokens, check their balances, and view the contract's transaction history.\n\nNow, Let's take a deep dive into the template. But before looking at the code, let's setup our metamask wallet and alchemy account.\n\n### MetaMask Installation & Configuration\n\n* To install MetaMask, first visit the MetaMask website (https://metamask.io/) and click the \"Get MetaMask\" button.  This will take you to the page for the MetaMask extension on the Chrome web store (https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn ), where you can click \"Add to Chrome\" to install the extension.  \n* Once the extension is installed, you will see the MetaMask icon appear in your browser's toolbar. Clicking on the icon will open the MetaMask pop-up window, where you can create a new account or import an existing one.\n* After creating an account, you will need to configure MetaMask to connect to the Ethereum network. To do this, click on the network dropdown in the top-left corner of the MetaMask window and select the network you want to connect to (e.g. \"Main Ethereum Network\" for the mainnet, or \"Goerli Test Network\" for the Goerli test network).  You can also add custom networks by clicking the \"Custom RPC\" option and entering the network's URL.\n* Once you have configured MetaMask to connect to the desired network, you can use it to manage your Ethereum accounts, sign transactions, and interact with decentralized applications.  You can also use MetaMask to switch between networks and test contracts without the need to run a full Ethereum node.\n\n### Getting access to Goerli Test network using Alchemy\n\n* To get access to an Alchemy node on the Goerli test network, you will first need to create an account on the Alchemy website (https://alchemy.com/). \n* Once your account is created, you will be able to log in to the Alchemy dashboard and access the network settings for the Goerli test network.  From there, you can generate an API key that you can use to connect to the Alchemy node.\n* To connect to the Alchemy node using the generated API key, you will need to use a library or tool that supports the Alchemy API. For example, if you are using the Web3.js library, you can connect to the Alchemy node by using the Web3.eth.alchemy method, passing in the API key as a parameter.\n* Once you are connected to the Alchemy node, you can use it to interact with the Goerli test network, including sending transactions and deploying and calling smart contracts. You can also use the Alchemy dashboard to monitor your node's performance and track your usage of the Alchemy API.\n\n### Template Code Setup\n\nNow, let's use the template code. To use the code in the DoDAO-io/dodao-simple-contract-template GitHub repository, you will need to have Node.js and npm installed on your computer. Once you have these tools installed, you can follow these steps to use the template code:\n* Download or clone the repository to your local computer using git:\n  ```\n  git clone https://github.com/DoDAO-io/dodao-simple-contract-template.git\n  ```\n* Navigate to the root directory of the repository and install the project dependencies using npm:\n  ```\n  npm install\n  ```\n\n* Compile the smart contract code by running the following command:\n  ```\n  npx hardhat compile\n  ```\n\n* Deploy the smart contract to the Goerli network by running the deploy script:\n  ```\n  npx hardhat run scripts/deploy.ts --network goerli\n  ```\n\n* Once the contract has been deployed, you can interact with it using the frontend directory. This directory contains a simple web application built with React that allows you to send and receive tokens using the deployed contract. To run the frontend, navigate to the frontend directory and run the following commands:\n  ```\n  cd frontend\n  npm install\n  npm start\n  ```\n\n* The frontend should now be running on your local computer. You can access it by visiting http://localhost:3000 in your web browser.\n* In addition to the steps above, the template also includes a Makefile that provides a number of useful commands for working with the project. For example, you can use the make compile command to compile the contract code. You can see the full list of commands by running make or make help.\n"
        },
        {
          "key": "smart-contract",
          "title": "Smart Contract Explanation & Deployment",
          "shortTitle": "Smart Contract",
          "details": "### Smart Contract\nIts time to have a look on the smart contract.\n\n```solidity\n//SPDX-License-Identifier: UNLICENSED\n// Solidity files have to start with this pragma. // It will be used by the Solidity compiler to validate its version. pragma solidity ^0.8.9;\n// We import this library to be able to use console.log import \"hardhat/console.sol\"; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n// This is the main building block for smart contracts. contract Token is ERC20 {\n    /**\n    * Contract initialization.\n    */\n    constructor() ERC20(\"My Hardhat Token\", \"MHT\") {\n        _mint(msg.sender, 1000000);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 2;\n    }\n\n    /**\n    * A function to transfer tokens.\n    *\n    * The `external` modifier makes a function *only* callable from outside\n    * the contract.\n    */\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        console.log(\n            \"Transferring from %s to %s %s tokens\",\n            msg.sender,\n            to,\n            amount\n        );\n\n        return super.transfer(to, amount);\n    }\n} \n```\n\nThe above smart contract is written in Solidity and defines a token contract called Token. The contract extends the ERC20 contract from the OpenZeppelin library, which provides a standard interface for ERC20 token contracts.\n\nThe contract's constructor function is called when the contract is deployed, and it initializes the contract with the name \"My Hardhat Token\" and the symbol \"MHT\".  It also uses the _mint function from the ERC20 contract to mint 1,000,000 tokens and transfer them to the contract's deployer.\n\nThe contract also defines a decimals function, which returns the number of decimal places used by the token. In this case, the function returns 2, indicating that the token uses 2 decimal places.\nThe contract also defines a transfer function, which allows users to transfer tokens from one account to another. The function logs the transfer information using the console.log function from the hardhat/console.sol library, and then calls the transfer function from the ERC20 contract using the super keyword to actually perform the transfer. This function is marked with the external modifier, which makes it only callable from outside the contract.\n\n### Deploying the smart contract \n\nTo deploy our smart contract, we used the following deploy script.\n\n```typescript\n\nimport { artifacts, ethers } from \"hardhat\"; import { Token } from \"./../typechain-types/contracts/Token\";\n\nasync function main() {\n  const Token = await ethers.getContractFactory(\"Token\");\n  const token = await Token.deploy();\n  await token.deployed();\n\n  console.log(\"Token address:\", token.address);\n\n  // We also save the contract's artifacts and address in the frontend directory\n  saveFrontendFiles(token);\n}\n// We recommend this pattern to be able to use async/await everywhere // and properly handle errors. main().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n// This is a script for deploying your contracts. You can adapt it to deploy // yours, or create new ones.\nconst path = require(\"path\");\nfunction saveFrontendFiles(token: Token) {\n  const fs = require(\"fs\");\n  const contractsDir = path.join(\n    __dirname,\n    \"..\",\n    \"frontend\",\n    \"src\",\n    \"contracts\"\n  );\n\n  if (!fs.existsSync(contractsDir)) {\n    fs.mkdirSync(contractsDir);\n  }\n\n  fs.writeFileSync(\n    path.join(contractsDir, \"contract-address.json\"),\n    JSON.stringify({ Token: token.address }, undefined, 2)\n  );\n\n  const TokenArtifact = artifacts.readArtifactSync(\"Token\");\n\n  fs.writeFileSync(\n    path.join(contractsDir, \"Token.json\"),\n    JSON.stringify(TokenArtifact, null, 2)\n  );\n\n  fs.cpSync(\n    path.join(__dirname, \"..\", \"typechain-types\"),\n    path.join(\n      __dirname,\n      \"..\",\n      \"frontend\",\n      \"src\",\n      \"contracts\",\n      \"typechain-types\"\n    ),\n    { recursive: true }\n  );\n}\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\n\n```\n\nThe above deploy script is written in TypeScript and is used to deploy the Token smart contract defined in Token.sol to an Ethereum network.  The script uses the Ethers.js library to interact with the Ethereum network and deploy the contract.\n\nThe script first imports the required dependencies, including the Token contract from the compiled Token.sol contract file and the ethers object from the Hardhat library.\n\nNext, the script defines a main function, which is the entry point for the script. This function first uses the ethers.getContractFactory function to create a contract factory for the Token contract,  and then uses the deploy method on the contract factory to deploy the contract to the network. The deployed method is called on the contract instance to wait for the deployment to be confirmed on the network.\n\nThe script then logs the contract's address to the console using the console.log function, and then saves the contract's address and ABI to the frontend directory using the saveFrontendFiles function.  This function writes the contract's address and ABI to a contract-address.json file and saves the contract's artifacts to a Token.json file in the frontend directory.\n\nOverall, this deploy script provides a simple and straightforward way to deploy the Token contract to an Ethereum network using Ethers.js. It also saves the deployed contract's address and ABI to the frontend directory,  making it easy to access these values in the front-end code.\n"
        },
        {
          "key": "frontend",
          "title": "Frontend Explanation",
          "shortTitle": "Frontend",
          "details": "### Frontend \n\nThe frontend of the template is a simple web application built with React that allows users to interact with the Token smart contract that is included in the template. The frontend code is located in the frontend directory of the repository, and is structured as follows:\n\n* `src/contracts: This directory contains the contract artifacts and address information that is needed to interact with the contract.  The contract artifacts are automatically generated by the hardhat tool when the contract is compiled, and the contract address is saved in a contract-address.json file by the deploy script.\n\n* `src/components`: This directory contains the React components that make up the user interface of the frontend. The main components are the App component, which is the root component of the application,  and the Token component, which is used to display and interact with the contract.\n\n* `src/index.tsx`: This is the entry point of the frontend application. It is responsible for rendering the App component to the page and initializing the ethers.js library, which is used to interact with the contract.\n\nTo use the frontend, you will need to have the Token contract deployed to the Ethereum network, and the contract address and artifacts will need to be saved in the src/contracts directory.  Once this is done, you can run the frontend by navigating to the frontend directory and running the following commands:\n\n```\ncd frontend \nnpm install \nnpm start \n```\n\nThe frontend should now be running on your local computer, and you can access it by visiting `http://localhost:3000` in your web browser. Once the frontend is running, you can start interacting with it.\n\n### Benefits of using Typescript\n\nAs you can see, we preferred using Typescript in our code instead of Javascript. There are several benefits to using generated typings (also known as type definitions or type declarations) in TypeScript.  These benefits include the following:\n\n* **Improved code correctness**: Generated typings provide type information for the objects and functions in your code, allowing the TypeScript compiler to catch type errors at compile time, rather than at runtime.  This can help you avoid runtime errors and improve the overall correctness of your code.\n\n* **Better code completion and documentation**: Generated typings can provide detailed type information for your code, allowing your code editor or IDE to provide accurate code completion suggestions and inline documentation.  This can help you write code more quickly and understand the APIs you are using more easily.\n\n* **Improved code maintainability**: Generated typings can help you refactor your code with confidence, by providing type information for the objects and functions in your code.  This can make it easier to update your code without breaking existing functionality.\n\n* **Easier integration with external libraries**: Many popular JavaScript libraries, such as React and lodash, provide generated typings that can be used with TypeScript.  This allows you to use these libraries in your TypeScript code with full type information, making it easier to integrate them into your project.\n\nOverall, using generated typings in TypeScript can help you write safer, more maintainable, and more robust code, and can make it easier to integrate your code with external libraries and frameworks.\n\n### How contract address is saved in contract-addresses.jon and how we access it in Frontend using ethers.js\n\nIn a typical Ethereum DApp, the contract address is saved in a file called `contract-addresses.json`, which is generated during the contract deployment process. This file is typically located in the root directory of the DApp's project, and it contains the contract's address, as well as any other relevant deployment information, such as the contract's ABI and the network it was deployed to.\nTo access the contract address in the DApp's front-end using Ethers.js, you will first need to import the contract-addresses.json file and use it to create a new instance of the Contract class from Ethers.js, passing in the contract's ABI and the contract address as parameters. For example, the code for creating a contract instance might look like this:\n\n```typescript\nimport contractAddress from \"@contracts/contract-address.json\"; import { ethers } from \"ethers\";\n// Create a new contract instance this._token = new ethers.Contract(\n      contractAddress.Token, // The contract address\n      TokenArtifact.abi,  // The contract ABI\n      this._provider.getSigner(0)\n    ) as Token;\n``` \n\nOnce you have created a contract instance, you can use it to call the contract's functions and access its state variables.  For example, you can use the contract instance to call the contract's balanceOf function to check the balance of a given account, or to call its transfer function to send tokens to another account. \n\nBy storing the contract address in contract-addresses.json and importing it in the front-end using Ethers.js, you can ensure that the DApp is always using the correct contract address,  regardless of which network it is deployed to or which version of the contract is currently active. This makes it easy to manage multiple contract deployments  and to switch between different networks without having to manually update the contract address in the front-end code.\n"
        }
      ],
      "questions": [
        {
          "uuid": "bb83adb7-229c-4193-bb48-dfbd4518b94a",
          "type": "SingleChoice",
          "content": "What programming language is used to write the smart contract in this template?",
          "hint": "NoHint",
          "explanation": "Solidity is a programming language for writing smart contracts that run on the Ethereum platform.",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Solidity",
              "key": "A"
            },
            {
              "content": "Javascript",
              "key": "B"
            },
            {
              "content": "C++",
              "key": "C"
            },
            {
              "content": "Python",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "8d68c818-725c-4f4b-8451-3dff8b7c9dd2",
          "type": "SingleChoice",
          "content": "What browser extension is used in this guide to interact with the Ethereum blockchain?",
          "hint": "Others are not extensions",
          "explanation": "MetaMask is a browser extension that allows users to interact with the Ethereum blockchain.",
          "answerKeys": [
            "B"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Solidity",
              "key": "A"
            },
            {
              "content": "MetaMask",
              "key": "B"
            },
            {
              "content": "Ethers.js",
              "key": "C"
            },
            {
              "content": "React",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "bbbd7f46-dcd0-48a4-8d03-5238ab832898",
          "type": "SingleChoice",
          "content": "What is Goerli?",
          "hint": "test network",
          "explanation": "Goerli is a public, proof-of-authority Ethereum test network that is designed to be a stable and reliable environment for testing and deploying decentralized applications (dApps).",
          "answerKeys": [
            "B"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A browser extension for interacting with Ethereum",
              "key": "A"
            },
            {
              "content": "A public, proof-of-authority Ethereum test network",
              "key": "B"
            },
            {
              "content": "A JavaScript library for working with Ethereum",
              "key": "C"
            },
            {
              "content": "A set of tools for running a local Ethereum development blockchain",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "deabbd6b-4684-4c46-911b-ac31f42a43e5",
          "type": "SingleChoice",
          "content": "What is Ethers.js?",
          "hint": "library",
          "explanation": "Ethers.js is a JavaScript library for working with the Ethereum blockchain.",
          "answerKeys": [
            "D"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "A blockchain infrastructure and development platform",
              "key": "A"
            },
            {
              "content": "A set of tools for running a local Ethereum development blockchain",
              "key": "B"
            },
            {
              "content": "A local Ethereum test network",
              "key": "C"
            },
            {
              "content": "A JavaScript library for working with Ethereum",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b873213e-cfb5-4dbd-8eac-9c2b819212c6",
          "type": "SingleChoice",
          "content": "What does the pragma solidity ^0.8.9; statement do in the smart contract code?",
          "hint": "NoHint",
          "explanation": "It sets the Solidity compiler version to 0.8.9. Solidity files have to start with this pragma. It will be used by the Solidity compiler to validate its version.",
          "answerKeys": [
            "B"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It imports the hardhat/console.sol library",
              "key": "A"
            },
            {
              "content": "It sets the Solidity compiler version to 0.8.9",
              "key": "B"
            },
            {
              "content": "It extends the ERC20 contract from the OpenZeppelin library",
              "key": "C"
            },
            {
              "content": "It defines a token contract called Token",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d7236343-5200-4dfe-9eaf-db5f0974c13e",
          "type": "SingleChoice",
          "content": "What does the `external` modifier do in the transfer function?",
          "hint": "external is synonymous to?",
          "explanation": "The `external` modifier makes a function only callable from outside the contract.",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It makes the function callable only from outside the contract",
              "key": "A"
            },
            {
              "content": "It makes the function callable only from within the contract",
              "key": "B"
            },
            {
              "content": "It logs the transfer information using the console.log function",
              "key": "C"
            },
            {
              "content": "It calls the transfer function from the ERC20 contract",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2263fb58-0ebf-45b3-bff4-a893d94241d2",
          "type": "SingleChoice",
          "content": "How do you compile the smart contract code in this template?",
          "hint": "NoHint",
          "explanation": "npx hardhat compile is used to compile the smart contract code.",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "npm compile",
              "key": "A"
            },
            {
              "content": "npm install",
              "key": "B"
            },
            {
              "content": "npx hardhat compile",
              "key": "C"
            },
            {
              "content": "npx hardhat",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "0990547f-8e92-4172-8a06-531dfcf9e7ea",
          "type": "SingleChoice",
          "content": "What is the use of Makefile?",
          "hint": "NoHint",
          "explanation": "A Makefile provides a number of useful commands for working with the project. For example, you can use the make compile command to compile the contract code. You can see the full list of commands by running make or make help.",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It provides a list of commands for working with the project",
              "key": "A"
            },
            {
              "content": "It compiles the smart contract code",
              "key": "B"
            },
            {
              "content": "It deploys the smart contract to the Ethereum network",
              "key": "C"
            },
            {
              "content": "It installs the project dependencies",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b891c509-19c1-4bb2-b68a-32e977d41743",
          "type": "MultipleChoice",
          "content": "What is the `await` keyword used for in the deploy script?",
          "hint": "NoHint",
          "explanation": "It is used to wait for a promise to be resolved and to handle asynchronous operations.It is used to pause the execution of the function until the asynchronous operation is completed",
          "answerKeys": [
            "A",
            "B"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is used to wait for a promise to be resolved",
              "key": "A"
            },
            {
              "content": "It is used to pause the execution of the function until the asynchronous operation is completed",
              "key": "B"
            },
            {
              "content": "It is used to skip a promise before it gets resolved",
              "key": "C"
            },
            {
              "content": "It is used to connect to the Ethereum network",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "58f2d52e-8bc0-4314-bb91-dbebbbc68ea5",
          "type": "SingleChoice",
          "content": "How does the deploy script save the contract's address and ABI to the frontend directory?",
          "hint": "saveFrontendFiles function",
          "explanation": "The script saves the contract's address and ABI to the frontend directory using the saveFrontendFiles function. This function writes the contract's address and ABI to a contract-address.json file and saves the contract's artifacts to a Token.json file in the frontend directory.",
          "answerKeys": [
            "D"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It writes the values to a contract-address.json file",
              "key": "A"
            },
            {
              "content": "It saves the contract's artifacts to a Token.json file",
              "key": "B"
            },
            {
              "content": "It creates a typechain-types directory",
              "key": "C"
            },
            {
              "content": "All of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "3a8028cd-c463-4f95-bb99-bdddff70ddd3",
          "type": "SingleChoice",
          "content": "What library is used to interact with the Ethereum network and deploy the contract in the deploy script?",
          "hint": "Others are not libraries.",
          "explanation": "Ethers.js is used to interact with the Ethereum network and deploy the contract in the deploy script",
          "answerKeys": [
            "B"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "TypeScript",
              "key": "A"
            },
            {
              "content": "Ethers.js",
              "key": "B"
            },
            {
              "content": "Hardhat",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f4cba509-9e5c-49b3-ae41-82fbcf3d63fc",
          "type": "SingleChoice",
          "content": "How do you access the contract address in the front-end of the DApp using Ethers.js?",
          "hint": "contract-address.json",
          "explanation": "We can access it by importing the contract-addresses.json file and use the ethers.getContractAt method",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Import the contract-addresses.json file and use the ethers.getContractAt method",
              "key": "A"
            },
            {
              "content": "Import the Token.json file and use the ethers.getContractAt method",
              "key": "B"
            },
            {
              "content": "Import the contract-addresses.json file and use the ethers.getContractFactory method",
              "key": "C"
            },
            {
              "content": "Import the Token.json file and use the ethers.getContractFactory method",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "f701470b-e4ae-4956-8b0b-6de89a950d78",
          "type": "SingleChoice",
          "content": "What does the deployed method do in the deploy script?",
          "hint": "NoHint",
          "explanation": "It waits for the contract deployment to be confirmed on the network",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It deploys the contract to the network",
              "key": "A"
            },
            {
              "content": "It saves the contract's artifacts to a file",
              "key": "B"
            },
            {
              "content": "It waits for the contract deployment to be confirmed on the network",
              "key": "C"
            },
            {
              "content": "It logs the contract's address to the console",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "de7c9983-8f8a-4b64-acde-a61db13791b8",
          "type": "SingleChoice",
          "content": "What does the saveFrontendFiles function do in the deploy script?",
          "hint": "NoHint",
          "explanation": "This function writes the contract's address and ABI to a contract-address.json file and saves the contract's artifacts to a Token.json file in the frontend directory.",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It saves the contract's address and ABI to the frontend directory",
              "key": "A"
            },
            {
              "content": "It deploys the contract to the network",
              "key": "B"
            },
            {
              "content": "It waits for the contract deployment to be confirmed on the network",
              "key": "C"
            },
            {
              "content": "It logs the contract's address to the console",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "e5a2d13f-2213-4ebb-8254-b0dd596d006b",
          "type": "SingleChoice",
          "content": "What is the fs.existsSync method used for in the deploy script?",
          "hint": "Does it exist?",
          "explanation": "It is used to check if a directory exists",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is used to create a directory",
              "key": "A"
            },
            {
              "content": "It is used to copy a directory",
              "key": "B"
            },
            {
              "content": "It is used to check if a directory exists",
              "key": "C"
            },
            {
              "content": "It is used to delete a directory",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [
        {
          "uuid": "f55641b5-9c37-4421-a082-01de070976cc",
          "shortTitle": "Solidity",
          "details": "This video enables learners to know about Solidity\n",
          "title": "Solidity Tutorial",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=ipwxYa-F1uY",
          "subTopics": []
        },
        {
          "uuid": "58729a9c-3253-4e7c-ba0b-3bfc3d4c51cb",
          "shortTitle": "Hardhat",
          "details": "This video enables learners to know about Hardat\n",
          "title": "Hardhat Tutorial",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=9Qpi80dQsGU",
          "subTopics": []
        },
        {
          "uuid": "855fd460-a945-4154-a6c1-74ee1f654781",
          "shortTitle": "Ethers.js",
          "details": "This video enables learners to know about Ethers.js\n",
          "title": "Ethers.js Tutorial",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=yk7nVp5HTCk&t=1927s",
          "subTopics": []
        },
        {
          "uuid": "5e99324c-c132-4baa-84db-10a92019e92e",
          "shortTitle": "React",
          "details": "This video enables learners to know about React\n",
          "title": "React Crash Course",
          "type": "YoutubeVideo",
          "url": "https://www.youtube.com/watch?v=w7ejDZ8SWv8",
          "subTopics": []
        }
      ],
      "summaries": []
    },
    {
      "title": "Simple Dapp for Aave Protocol",
      "key": "simple-dapp-for-aave-protocol",
      "details": "This chapter discusses about the starter dapp [template](https://github.com/DoDAO-io/dodao-simple-contract-template) in detail. \n",
      "order": 3,
      "explanations": [
        {
          "key": "intro",
          "title": "Introduction",
          "shortTitle": "Introduction",
          "details": "### Problem Statement Aave is a decentralized finance (DeFi) platform that offers users the ability to lend and borrow cryptocurrency. The platform specializes in overcollateralized loans, where borrowers must deposit a higher value of cryptocurrency than the amount they wish to borrow. This protects lenders from potential losses due to loan defaults, and allows the Aave protocol to liquidate the collateral if it decreases significantly in value.\nOur goal is to build a simple example of how to build a Dapp that allows users to interact with the Aave protocol on the Ethereum blockchain and demonstrate how you can further interact with Aave and build applications on top of it. \nSo, the idea for this DApp is to allow users to receive undercollateralized loan from Aave. For this, we will create a DApp that works on top of Aave smart contracts and adds part of the collateral from our side so that the user receives more loan from Aave than the amount of collateral he has deposited and Aave is still providing overcollateralized loan, so a win-win for both sides. The amount of collateral we top up is 50% of the amount eligible for the user.  So the user supplies USDC tokens and receives LINK tokens in return based on the USDC threshold in Aave i.e. 85%. Our contract then tops up the user's LINK amount by 50% of the eligibility.\nHere is a screenshot of the application:\n\nTo create the DApp we used the [starter dapp template](https://github.com/DoDAO-io/dodao-simple-contract-template) that we built in the previous chapter. \n### Template Overview\n* Solidity (To write our smart contract) * Hardat (build, test and deployment framework) * React (Create our frontend) * Ethers (web3 library for interacting with the blockchain and our smart contract) * MetaMask (Wallet browser extension) * Alchemy (node provider)\nThe starter template uses the above stack/tools. So, before moving forward make sure to have the initial setup ready following the previous chapter.\nNow, let's move on to the code setup for the DApp which we will discuss in this chapter. You can find the complete code [here](https://github.com/DoDAO-io/aave-call-smart-contracts).\n"
        },
        {
          "key": "setup",
          "title": "Code Setup",
          "shortTitle": "Setup",
          "details": "To use the code in the DoDAO-io/aave-call-smart-contracts GitHub repository, you will need to have Node.js and npm installed on your computer. Once you have these tools installed, you can follow these steps to setup the code:\n* Download or clone the repository to your local computer using git:\n  ```\n  git clone https://github.com/DoDAO-io/aave-call-smart-contracts.git \n  ```\n\n* Navigate to the root directory of the repository and install the project dependencies using npm:\n  ```\n  npm install\n  ```\n\n* Compile the smart contract code by running the following command:\n  ```\n  npx hardhat compile\n  ```\n\n* Deploy the smart contract to the Goerli network by running the deploy script:\n  ```\n  npx hardhat run scripts/compile.ts\n  npx hardhat run scripts/old-deploy.ts --network goerli\n  ```\n\n* We use an upgradable smart contract, so to deploy it after making changes you can use:\n  ```\n  npx hardhat run scripts/update.ts --network goerli\n  ```\n\n* Once the contract has been deployed, you can interact with it using the frontend directory. This directory contains a simple web application built with React that allows you to send and receive tokens using the deployed contract. To run the frontend, navigate to the frontend directory and run the following commands:\n  ```\n  cd frontend\n  npm install\n  npm start\n  ```\n  \n* The frontend should now be running on your local computer. You can access it by visiting `http://localhost:3000` in your web browser.\n* In addition to the steps above, the template also includes a Makefile that provides a number of useful commands for working with the project. For example, you can use the make compile command to compile the contract code. You can see the full list of commands by running make or make help.\n"
        },
        {
          "key": "smart-contract",
          "title": "Code Explanation",
          "shortTitle": "Explanation",
          "details": "### Smart Contract\n```solidity\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.10; pragma abicoder v2;\nimport \"@aave/core-v3/contracts/interfaces/IPool.sol\"; import \"@aave/core-v3/contracts/interfaces/IAaveOracle.sol\"; import \"@aave/core-v3/contracts/interfaces/IPriceOracleGetter.sol\"; import \"@aave/core-v3/contracts/misc/AaveOracle.sol\"; import \"@aave/core-v3/contracts/protocol/libraries/configuration/ReserveConfiguration.sol\"; import \"@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol\"; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; import \"hardhat/console.sol\";\ncontract Aave {\n\n    // Storage Variables\n    address public borrowTokenAddress = 0x07C725d58437504CA5f814AE406e70E21C5e8e9e;\n    address public supplyTokenAddress = 0xA2025B15a1757311bfD68cb14eaeFCc237AF5b43;\n    address public aavePoolAddress = 0x368EedF3f56ad10b9bC57eed4Dac65B26Bb667f6;\n    address public dataProviderAddress = 0x9BE876c6DC42215B00d7efe892E2691C3bc35d10;\n    address public aaveOracleAddress = 0x5bed0810073cc9f0DacF73C648202249E87eF6cB;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n\n    function supply(uint _userAmount) public returns (bool) {\n\n        // Top up the collateral to double\n        uint _total = _userAmount * 2;\n\n\n        // Transfer _useramount from user to contract\n        IERC20(supplyTokenAddress).transferFrom(msg.sender, address(this), _userAmount * 1000000);\n\n        // Get the reserveData as that contains the threshold i.e. the max amount of assert that can be bought against USDC\n        DataTypes.ReserveData memory reserveData = IPool(aavePoolAddress).getReserveData(supplyTokenAddress);\n\n        // prices are returned in USD with 6 decimal places\n        uint256 linkPrice = IPriceOracleGetter(aaveOracleAddress).getAssetPrice(borrowTokenAddress);\n\n        // normalize the amount and reduce the six decimal digits\n        uint256 linkPriceInUSDC = linkPrice / 100000000;\n\n        // threshold is returned as 8500, so we need to normalize it\n        uint256 threshold = reserveData.configuration.getLiquidationThreshold();\n\n        // Supply _total i.e. double the users amount to Aave pool\n        IERC20(supplyTokenAddress).approve(aavePoolAddress, _total * 1000000);\n        IPool(aavePoolAddress).supply(supplyTokenAddress, _total * 1000000, address(this), 0);\n\n        // divide by 10000 as the threshold is 8500 i.e. 85%\n        uint256 userUSDCBorrowAmount = (_userAmount * threshold) / 10000 ;\n\n        // USDC amount to be used for borrow - we borrow 1.5 times the max user limit\n        uint256 usdcBorrowAmount = (userUSDCBorrowAmount * 3) / 2 ;\n\n        // USDC amount to be used for borrow - we borrow 1.5 times the max user limit\n        uint256 numberOfLinkTokens = usdcBorrowAmount / linkPriceInUSDC ;\n\n        console.log(\"Trying to borrow %s link after adding %s USDC. Users eligible borrow amount is\", numberOfLinkTokens, _total, userUSDCBorrowAmount);\n\n        // Borrow the LINK tokens from Aave\n        IPool(aavePoolAddress).borrow(borrowTokenAddress, numberOfLinkTokens * 1 ether, 2, 0, address(this));\n\n\n        // Transfer LINK to user\n        IERC20(borrowTokenAddress).transfer(msg.sender, numberOfLinkTokens * 1 ether);\n\n        return true;\n    }\n\n}\n```\nThe Aave.sol contract has one main function, supply(), which allows users to supply collateral to the Aave protocol and use it to borrow other assets. The supply() function takes in an input, _userAmount, which specifies the amount of collateral that the user wants to supply. The function then uses this input to do the following: Transfer the user-specified amount of collateral from the user's account to the contract's account.\nUse the supplied collateral to borrow a specified amount of another asset. Transfer the borrowed asset to the user's account. The supply() function uses various interfaces and libraries to interact with other contracts on the Aave protocol. For example, the IPool interface is used to interact with the Aave pool, which is where users can supply their collateral and borrow assets. The IERC20 interface is used to interact with the ERC-20 tokens used on the protocol. The AaveOracle contract is used to get the current price of the asset being borrowed.\nAt the top of the contract, several other contracts are imported. These include contracts for interfacing with the Aave protocol, a contract for handling ERC20 tokens, and a contract for logging messages to the console. The contract has one public function called supply. This function takes a single argument, an unsigned integer called _userAmount. The function returns a single boolean value indicating whether the function executed successfully. The function first calculates the total amount to be supplied to the Aave pool by multiplying the user's supplied amount by 2. It then transfers the user's supplied amount from the user's address to the contract's address using the transferFrom method on the IERC20 contract. Then it retrieves the reserve data for the supply token using the getReserveData method on the IPool contract. This data contains the maximum amount of assets that can be bought against the USDC token. Then uses the getAssetPrice method on the IPriceOracleGetter contract to get the price of the borrow token in USD. This price is then divided by 100000000 to normalize it and remove the extra decimal places. Then the function calculates the user's eligible borrow amount by multiplying the user's supplied amount by the liquidation threshold from the reserve data, and dividing that result by 10000. This borrow amount is then multiplied by 1.5 to get the total amount of USDC to be used for borrowing. Then it calculates the number of LINK tokens to be borrowed by dividing the USDC borrow amount by the normalized price of the borrow token in USDC. This value is then logged to the console. The function then uses the approve and borrow methods on the IPool contract to borrow the calculated number of LINK tokens. The borrowed tokens are then transferred to the user's address using the transfer method on the IERC20 contract.\n### Update.ts\nThe most important behavior of this file is that it upgrades an instance of the deployed contract on the Ethereum blockchain. The code uses the hardhat and ethers libraries to connect to the network and interact with the contract, and it uses the upgradeProxy method from the upgrades module to upgrade the contract. This allows the contract's bytecode to be updated without affecting its state or its address on the blockchain.\nContract upgrades are a common practice in Ethereum development. As smart contracts are immutable and cannot be modified once deployed, developers must create new versions of their contracts when they want to make changes to the contract's behavior. However, simply deploying a new contract would require users to update their contract references and migrate their data to the new contract.\nTo avoid this problem, Ethereum provides a mechanism for upgrading contracts called proxy contracts. A proxy contract is a special type of contract that acts as a middleman between the user and the actual contract. The proxy contract has a reference to the actual contract, and it forwards calls and transactions to the actual contract. When the actual contract needs to be updated, the developer can simply deploy a new version of the contract and update the proxy contract to point to the new contract. This allows the contract to be updated without affecting its address or its state, and without requiring users to update their contract references or migrate their data.\nIn the code above, the upgradeProxy method is used to upgrade the contract by deploying a new version of the contract and updating the proxy contract to point to the new contract. This allows the contract to be updated without affecting its address or its state, and without requiring users to update their contract references or migrate their data.\n"
        },
        {
          "key": "helper-components",
          "title": "Helper Components",
          "shortTitle": "Helpers",
          "details": "### PoolSlice.ts\nThe code imports several modules from the @aave/contract-helpers package, which provides a set of functions that make it easier to work with the Aave protocol, a decentralized lending and borrowing platform built on the Ethereum blockchain. The code defines an enum called ChainId, which lists several different Ethereum networks, including mainnet, ropsten, rinkeby, and goerli.\nThe code then defines an object called marketInfo that contains information about the Ethereum Görli network. This object includes the chainId of the Görli network, as well as the addresses of various contracts that are used by the Aave protocol on that network.\nThe code also defines an interface called SupplyActionProps that describes the shape of an object that is passed to a function called createPoolSlice. This function takes an account and a provider as arguments and returns an object with several methods for interacting with the Aave protocol. One of these methods, getPool, returns an instance of the Pool class from the @aave/contract-helpers package, which provides functions for working with Aave pools. Another method, getPoolData, uses the UiPoolDataProvider class from the @aave/contract-helpers package to retrieve data about an Aave pool.\nOverall, this code provides a set of tools for working with the Aave protocol on the Ethereum Görli network.\n### ContractsHelper.ts\nThis code provides a set of utility functions for working with the USDC and Link ERC-20 tokens on the Ethereum network. The getTokenContract function allows you to obtain an instance of the IERC20__factory interface connected to the USDC or Link contract, depending on the tokenType parameter passed to the function. This instance can be used to interact with the contract and perform various operations, such as checking a user's balance or transferring tokens.\nThe getNormalizedBalance function provides a convenient way to retrieve a user's token balance and convert it to a human-readable format. It does this by dividing the user's balance by the appropriate constant value (either 1,000,000 for USDC or 1,000,000,000,000,000,000 for Link), and returning the result as a BigNumber object. This allows you to easily display the user's balance in your application without worrying about the underlying details of how the balance is represented on the blockchain.\n"
        },
        {
          "key": "main-components",
          "title": "Main Components",
          "shortTitle": "Main Components",
          "details": "### DApp.tsx\nThis is the main React component of our app that provides a user interface for interacting with the Aave protocol. The component connects to the user's Ethereum wallet, initializes the Aave contract, and polls the user's balance to keep it updated. It also provides a way for users to supply assets to Aave pools and to mint USDC tokens.\nThe component uses the @components/aave/MintUSDC and @components/aave/Supply components to render the user interface. It also imports the ConnectWallet component, which displays a message asking the user to connect their wallet if one is not detected. The component also imports the TransactionErrorMessage and WaitingForTransactionMessage components, which are used to display messages to the user if there is an error sending a transaction or if the component is waiting for a transaction to be processed.\nThe Dapp component uses the ethers library to connect to the Ethereum network and interact with the Aave contract. It also uses the typechain-types package to access the types and artifacts for the Aave contract. The component maintains its state using the React.Component class's state property, and it updates the user's balance by polling the Aave contract. The component also provides several methods for working with the Aave contract, including mintUSDC, aaveSupply, and getBalance.\nOverall, this code provides a user interface for interacting with the Aave protocol on the Ethereum blockchain. It allows users to supply assets to Aave pools and to mint USDC tokens, and it provides a way to view the user's balance and transaction history.\n### MintUSDC.tsx\nIt is a React component called \"MintUSDC\" that allows a user to mint USDC tokens and transfer them to a contract. The component has two buttons, one to mint 10K USDC tokens to the user's account and the other to transfer 2K USDC tokens to the contract. The component also displays the user's and contract's current USDC balances.\nThe component uses the getTokenContract function from the contractsHelper module to get the USDC token contract and the createPoolSlice function from the aave/poolSlice module to create a pool slice instance. The mintOneUSDC function is called when the user clicks the \"Mint 10K USDC\" button and it uses the pool slice instance to mint 10K USDC tokens to the user's account. The transferUSDCToContract function is called when the user clicks the \"Transfer 2K USDC\" button and it uses the USDC token contract to transfer 2K USDC tokens to the contract's address. Both functions also update the user's and contract's USDC balances by calling the updateUserUSDCBalance and updateContractBalance functions respectively. These functions use the getNormalizedBalance function from the contractsHelper module to get the user's and contract's normalized USDC balances.\n### Supply.tsx\nThe code is a React component called \"Supply\" that allows users to supply USDC to the Aave lending protocol and receive LINK in return. It uses several helper functions from the \"@components/helpers/contractsHelper\" module to get information about the user's account and the state of the Aave protocol. It also imports the createPoolSlice function from the \"@components/aave/poolSlice\" module to get information about the Aave reserve pools.\nIt takes in two props: an account string representing the user's Ethereum address, and a provider object that allows the component to interact with the Ethereum network.\nThis component has several state variables to track the user's account, the contract's USDC balance, the amount of USDC being supplied, the current USDC threshold, the current LINK price, and the amount of mintable and top-up LINK. The component also has several functions to update these state variables, such as updateUserLINKBalance, getBalance, and updateReserveInfo.\nThe component has an input field where the user can enter the amount of USDC they want to supply, and a button to trigger the aaveSupply function. This function connects to the Aave contract, approves the transfer of USDC from the user's account to the contract, and calls the contract's supply function with the specified amount of USDC. After the transaction is complete, the component updates the contract's USDC balance and the user's LINK balance.\nThe component also has a refreshPage function that reloads the page, and a calculateLinks function that calculates the amount of mintable and top-up LINK based on the current state of the Aave protocol. This information is displayed to the user in the component's UI.\n"
        }
      ],
      "questions": [
        {
          "uuid": "c3d3f64f-607f-4b29-be5f-addf914a39b7",
          "type": "SingleChoice",
          "content": "What is the purpose of the IPriceOracleGetter contract imported in the Aave contract?",
          "hint": "NoHint",
          "explanation": "The purpose of the IPriceOracleGetter contract imported in the Aave contract is to get the price of a token in USD.",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "To get the price of a token in USD",
              "key": "A"
            },
            {
              "content": "To get the data of the Aave pool",
              "key": "B"
            },
            {
              "content": "To get the data of the user's reserve",
              "key": "C"
            },
            {
              "content": "To get the configuration of the reserve",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "b50233ce-b65e-4776-99e7-c73348055e36",
          "type": "SingleChoice",
          "content": "What is the purpose of the supplyTokenAddress variable in the contract?",
          "hint": "ERC20 token",
          "explanation": "It is used to store the address of the ERC20 token that is being supplied to the Aave pool.",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It is used to store the address of the Aave pool contract",
              "key": "A"
            },
            {
              "content": "It is used to store the address of the ERC20 token that is being borrowed from the Aave pool",
              "key": "B"
            },
            {
              "content": "It is used to store the address of the ERC20 token that is being supplied to the Aave pool",
              "key": "C"
            },
            {
              "content": "It is used to store the address of the Aave Oracle contract",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "13586d9e-88f1-438f-b139-7ffa435ea9ef",
          "type": "SingleChoice",
          "content": "What is the name of the function that is used to borrow tokens in the contract?",
          "hint": "Supply? Nah, definitely Borrow",
          "explanation": "Borrow function is used to borrow tokens in the contract.",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "getReserveData",
              "key": "A"
            },
            {
              "content": "supply",
              "key": "B"
            },
            {
              "content": "borrow",
              "key": "C"
            },
            {
              "content": "getAssetPrice",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "96cc791c-a34c-404a-a936-99a0eb4974fe",
          "type": "SingleChoice",
          "content": "What is a proxy contract in Ethereum development?",
          "hint": "middleman",
          "explanation": "A proxy contract in Ethereum development is a special type of contract that acts as a middleman between the user and the actual contract.",
          "answerKeys": [
            "D"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "A contract that is deployed when a new version of the contract needs to be created",
              "key": "A"
            },
            {
              "content": "A contract that is deployed when the contract's bytecode needs to be updated",
              "key": "B"
            },
            {
              "content": "A contract that is deployed when the contract's state needs to be updated",
              "key": "C"
            },
            {
              "content": "A special type of contract that acts as a middleman between the user and the actual contract",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "babbd1d5-245b-469f-8a44-d341a0e1b46c",
          "type": "SingleChoice",
          "content": "What is the advantage of using a proxy contract for contract upgrades?",
          "hint": "NoHint",
          "explanation": "Ethereum provides a mechanism for upgrading contracts called proxy contracts. A proxy contract is a special type of contract that acts as a middleman between the user and the actual contract. The proxy contract has a reference to the actual contract, and it forwards calls and transactions to the actual contract. When the actual contract needs to be updated, the developer can simply deploy a new version of the contract and update the proxy contract to point to the new contract. This allows the contract to be updated without affecting its address or its state, and without requiring users to update their contract references or migrate their data.",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It allows the contract to be updated without affecting its address or its state",
              "key": "A"
            },
            {
              "content": "It allows the contract to be updated without requiring users to migrate their data",
              "key": "B"
            },
            {
              "content": "Both of the above",
              "key": "C"
            },
            {
              "content": "None of the above",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "6f9f7840-a89b-43de-b8bf-d8d6bdfd2b19",
          "type": "SingleChoice",
          "content": "What does the getNormalizedBalance function do?",
          "hint": "NoHint",
          "explanation": "It returns the normalized balance of a token for the specified provider and account.",
          "answerKeys": [
            "B"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "Returns the USDC balance of the contract",
              "key": "A"
            },
            {
              "content": "Returns the normalized balance of a token for the specified provider and account",
              "key": "B"
            },
            {
              "content": "Returns the USDC balance of the user",
              "key": "C"
            },
            {
              "content": "Returns the address of the USDC contract",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ea59d9af-ccb4-4253-b86f-84aa69f60b60",
          "type": "SingleChoice",
          "content": "What is the purpose of the MintUSDC component?",
          "hint": "mint and transfer",
          "explanation": "The purpose of the MintUSDC component is to mint USDC tokens and transfer them to the user's account.",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "To mint USDC tokens and transfer them to the user's account",
              "key": "A"
            },
            {
              "content": "To transfer USDC tokens from a contract address to the user's account",
              "key": "B"
            },
            {
              "content": "To transfer USDC tokens from the user's account to a contract address",
              "key": "C"
            },
            {
              "content": "To mint USDC tokens and transfer them to the contract address",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2ea0b8fb-f77d-4ee1-85a3-d5e97e0b261e",
          "type": "SingleChoice",
          "content": "What is the purpose of the IERC20__factory.connect method?",
          "hint": "connect",
          "explanation": "It connects the IERC20 contract to the Ethereum network.",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "It creates a new instance of the IERC20 contract",
              "key": "A"
            },
            {
              "content": "It creates a new provider using window.ethereum",
              "key": "B"
            },
            {
              "content": "It connects the IERC20 contract to the Ethereum network",
              "key": "C"
            },
            {
              "content": "It connects the Dapp component to the Ethereum network",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "a69bd10a-9ef1-4319-baa8-ad24dff23589",
          "type": "SingleChoice",
          "content": "How does the Supply component calculate the amount of LINK that can be minted from a USDC supply?",
          "hint": "multiply",
          "explanation": "It multiplies the supply amount by the USDC threshold.",
          "answerKeys": [
            "D"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "It divides the supply amount by the link price",
              "key": "A"
            },
            {
              "content": "It multiplies the supply amount by the link price",
              "key": "B"
            },
            {
              "content": "It divides the supply amount by the USDC threshold",
              "key": "C"
            },
            {
              "content": "It multiplies the supply amount by the USDC threshold",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "7b035f74-b4c3-487e-887b-9fa3ae4fa042",
          "type": "SingleChoice",
          "content": "What is the purpose of the updateContractBalance function?",
          "hint": "USDC token",
          "explanation": "The function updates the USDC balance of the contract.",
          "answerKeys": [
            "B"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "To update the USDC balance of the user",
              "key": "A"
            },
            {
              "content": "To update the USDC balance of the contract",
              "key": "B"
            },
            {
              "content": "To update the balance of the user for all supported tokens",
              "key": "C"
            },
            {
              "content": "To update the balance of the contract for all supported tokens",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ff9ae8a3-36f0-45b1-a0a1-b8bfc76b361f",
          "type": "SingleChoice",
          "content": "What is the purpose of the getTokenContract function?",
          "hint": "NoHint",
          "explanation": "It's purpose is to get the contract instance of the specified token.",
          "answerKeys": [
            "B"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "To get the contract address of the specified token",
              "key": "A"
            },
            {
              "content": "To get the contract instance of the specified token",
              "key": "B"
            },
            {
              "content": "To get the contract balance of the specified token",
              "key": "C"
            },
            {
              "content": "To get the contract owner of the specified token",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "1ccfce22-265a-45a0-9890-51768866db62",
          "type": "SingleChoice",
          "content": "What is the value of normalizedBalance after the following code executes? ```const userTokenBalance = BigNumber.from(\"5000000000\"); const normalizedBalance = userTokenBalance.div( BigNumber.from(\"1000000\").toString() ); ```",
          "hint": "divide",
          "explanation": "5000000000/1000000 = 5000",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Medium",
          "choices": [
            {
              "content": "5",
              "key": "A"
            },
            {
              "content": "500",
              "key": "B"
            },
            {
              "content": "5000",
              "key": "C"
            },
            {
              "content": "5000000",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "d822db56-f5c8-467f-b73f-44804654ef2e",
          "type": "SingleChoice",
          "content": "What is the purpose of the FaucetService class?",
          "hint": "NoHint",
          "explanation": "The purpose of the FaucetService class is to provide users with access to Aave faucet contract instances.",
          "answerKeys": [
            "C"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "To provide users with access to testnet Aave faucets",
              "key": "A"
            },
            {
              "content": "To provide users with access to mainnet Aave faucets",
              "key": "B"
            },
            {
              "content": "To provide users with access to Aave faucet contract instances",
              "key": "C"
            },
            {
              "content": "To provide users with access to Aave faucet contract addresses",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "2362691f-e0f1-4bdb-8f62-e719f46c4c37",
          "type": "SingleChoice",
          "content": "What is the purpose of the createPoolSlice function?",
          "hint": "NoHint",
          "explanation": "To create a new Map containing pool data.",
          "answerKeys": [
            "D"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "To create a new instance of the Pool class",
              "key": "A"
            },
            {
              "content": "To create a new instance of the LendingPool class",
              "key": "B"
            },
            {
              "content": "To create a new instance of the UiPoolDataProvider class",
              "key": "C"
            },
            {
              "content": "To create a new Map containing pool data",
              "key": "D"
            }
          ]
        },
        {
          "uuid": "ebad7060-442a-4f39-977c-c189a98f5c22",
          "type": "SingleChoice",
          "content": "What is the value of the marketInfo.marketTitle constant?",
          "hint": "The test network we used.",
          "explanation": "Ethereum Görli is the value of the marketInfo.marketTitle constant.",
          "answerKeys": [
            "A"
          ],
          "difficultyLevel": "Low",
          "choices": [
            {
              "content": "Ethereum Görli",
              "key": "A"
            },
            {
              "content": "Ethereum Rinkeby",
              "key": "B"
            },
            {
              "content": "Ethereum Mainnet",
              "key": "C"
            },
            {
              "content": "Ethereum Kovan",
              "key": "D"
            }
          ]
        }
      ],
      "readings": [],
      "summaries": []
    }
  ]
}